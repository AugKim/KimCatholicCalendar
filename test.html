<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test L·ªãch Ph·ª•ng V·ª• - B·ªô Ti√™u Chu·∫©n Ki·ªÉm Th·ª≠</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .test-pass { background-color: #dcfce7; color: #166534; }
        .test-fail { background-color: #fee2e2; color: #991b1b; }
        .test-warn { background-color: #fef3c7; color: #92400e; }
        .test-section { background-color: #e0f2fe; color: #0369a1; font-weight: bold; }
        .test-info { background-color: #f9fafb; }
        .log-entry { font-family: monospace; font-size: 0.85rem; padding: 4px 8px; border-bottom: 1px solid #e5e7eb; }
        .log-entry.hidden { display: none; }
        #testLog { max-height: 600px; overflow-y: auto; }
        
        /* Filter button styles */
        .filter-btn { cursor: pointer; }
        .filter-btn.active { border-color: #3b82f6 !important; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        #btnAll.active { border-color: #6b7280 !important; box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.3); }
        #btnPass.active { border-color: #16a34a !important; box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.3); }
        #btnFail.active { border-color: #dc2626 !important; box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.3); }
        #btnWarn.active { border-color: #d97706 !important; box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.3); }
    </style>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-2">üß™ Test L·ªãch Ph·ª•ng V·ª•</h1>
        <p class="text-center text-gray-500 mb-8">B·ªô Ti√™u Chu·∫©n Ki·ªÉm Th·ª≠ To√†n Di·ªán</p>
        
        <!-- Controls -->
        <div class="bg-white p-6 rounded-xl shadow-md mb-6">
            <div class="flex flex-wrap gap-4 items-end">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">NƒÉm b·∫Øt ƒë·∫ßu</label>
                    <input type="number" id="startYear" value="2000" class="border rounded px-3 py-2 w-24">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">NƒÉm k·∫øt th√∫c</label>
                    <input type="number" id="endYear" value="2100" class="border rounded px-3 py-2 w-24">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Lo·∫°i test</label>
                    <select id="testType" class="border rounded px-3 py-2">
                        <option value="all">üîÑ T·∫•t c·∫£</option>
                        <option value="standards">üìã Ti√™u chu·∫©n (A-E)</option>
                        <option value="dateISO">üìÖ A. Date & ISO-key</option>
                        <option value="schema">üìù B. Schema Validation</option>
                        <option value="business">‚õ™ C. Nghi·ªáp v·ª• Ph·ª•ng v·ª•</option>
                        <option value="monthGrid">üìÜ D. Month Grid</option>
                        <option value="regression">üîÅ E. Regression</option>
                        <option value="easter">üê£ Easter/Ph·ª•c Sinh</option>
                        <option value="epiphany">‚≠ê Hi·ªÉn Linh & Ph√©p R·ª≠a</option>
                        <option value="lent">‚úùÔ∏è M√πa Chay</option>
                        <option value="advent">üïØÔ∏è M√πa V·ªçng</option>
                        <option value="tet">üéä T·∫øt Nguy√™n ƒê√°n</option>
                        <option value="readingCode">üìñ Quy T·∫Øc M√£ B√†i ƒê·ªçc</option>
                        <option value="validateCodeFormat">‚úÖ Ki·ªÉm Tra Format M√£ Code</option>
                        <option value="strictRules">‚öñÔ∏è Quy Lu·∫≠t Ph·ª•ng V·ª• (Strict)</option>
                    </select>
                </div>
                <button onclick="runTests()" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 font-semibold">
                    ‚ñ∂ Ch·∫°y Test
                </button>
                <button onclick="runStandardTests()" class="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700 font-semibold">
                    üìã Ch·∫°y Ti√™u Chu·∫©n
                </button>
                <button onclick="clearLog()" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                    X√≥a Log
                </button>
            </div>
        </div>
        
        <!-- Summary - Filter Buttons -->
        <div class="grid grid-cols-4 gap-4 mb-6">
            <button onclick="filterLog('all')" id="btnAll" title="Hi·ªÉn th·ªã t·∫•t c·∫£" class="filter-btn active bg-white p-4 rounded-xl shadow-md text-center hover:bg-gray-50 transition-all border-2 border-transparent focus:outline-none">
                <div id="totalTests" class="text-3xl font-bold text-gray-800">0</div>
                <div class="text-sm text-gray-500">T·ªïng Tests</div>
                <div class="text-xs text-gray-400 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
            <button onclick="filterLog('pass')" id="btnPass" title="Ch·ªâ hi·ªÉn th·ªã passed" class="filter-btn bg-green-50 p-4 rounded-xl shadow-md text-center hover:bg-green-100 transition-all border-2 border-transparent focus:outline-none">
                <div id="passedTests" class="text-3xl font-bold text-green-600">0</div>
                <div class="text-sm text-green-700">Passed</div>
                <div class="text-xs text-green-500 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
            <button onclick="filterLog('fail')" id="btnFail" title="Ch·ªâ hi·ªÉn th·ªã failed" class="filter-btn bg-red-50 p-4 rounded-xl shadow-md text-center hover:bg-red-100 transition-all border-2 border-transparent focus:outline-none">
                <div id="failedTests" class="text-3xl font-bold text-red-600">0</div>
                <div class="text-sm text-red-700">Failed</div>
                <div class="text-xs text-red-400 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
            <button onclick="filterLog('warn')" id="btnWarn" title="Ch·ªâ hi·ªÉn th·ªã warnings" class="filter-btn bg-yellow-50 p-4 rounded-xl shadow-md text-center hover:bg-yellow-100 transition-all border-2 border-transparent focus:outline-none">
                <div id="warnTests" class="text-3xl font-bold text-yellow-600">0</div>
                <div class="text-sm text-yellow-700">Warnings</div>
                <div class="text-xs text-yellow-500 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
        </div>
        
        <!-- Test Log -->
        <div class="bg-white rounded-xl shadow-md overflow-hidden">
            <div class="bg-gray-800 text-white px-4 py-2 font-semibold flex justify-between items-center">
                <span>üìã Test Log</span>
                <span id="testProgress" class="text-sm text-gray-300"></span>
            </div>
            <div id="testLog" class="bg-gray-50"></div>
        </div>
        
        <!-- Detailed Year View -->
        <div id="detailView" class="mt-6 hidden">
            <div class="bg-white rounded-xl shadow-md p-6">
                <h2 class="text-xl font-bold mb-4">üìÖ Chi ti·∫øt nƒÉm <span id="detailYear"></span></h2>
                <div id="detailContent" class="grid grid-cols-2 gap-4"></div>
            </div>
        </div>
    </div>

    <!-- Load all reading data files -->
    <script src="Reading/readingdata.js"></script>
    <script src="Reading/readings_year_1.js"></script>
    <script src="Reading/readings_year_2.js"></script>
    <script src="Reading/Sunday.js"></script>
    <script src="Reading/DailySeason.js"></script>
    <script src="Reading/Saints.js"></script>
    <script src="Reading/SaintsBible.js"></script>
    <script src="Reading/Optionsaint.js"></script>
    <script src="Reading/eucharisticAdoration.js"></script>
    <script src="js/controller.js"></script>
    
    <script>
        // ============================================================
        // TEST UTILITIES & STATISTICS
        // ============================================================
        
        let stats = { total: 0, passed: 0, failed: 0, warnings: 0 };
        
        // Enum definitions for validation
        const VALID_RANKS = ['TRONG', 'KINH', 'NHO', 'NHOKB', 'CHUA_NHAT', 'NGAY_THUONG', 'O'];
        const VALID_COLORS = ['bg-lit-green', 'bg-lit-purple', 'bg-lit-white', 'bg-lit-red', 'bg-lit-rose'];
        const VALID_SEASONS = ['M√πa Th∆∞·ªùng Ni√™n', 'M√πa V·ªçng', 'M√πa Gi√°ng Sinh', 'M√πa Chay', 'M√πa Ph·ª•c Sinh', 'Tam Nh·∫≠t V∆∞·ª£t Qua'];
        
        // ============================================================
        // A. DATE & ISO-KEY UTILITIES (Timezone Safety)
        // ============================================================
        
        // Chu·∫©n: toISODate lu√¥n tr·∫£ YYYY-MM-DD ƒë√∫ng theo ng√†y ƒë·ªãa ph∆∞∆°ng
        function toISODate(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Chu·∫©n: Parse date-string kh√¥ng d√πng new Date("YYYY-MM-DD") v√¨ c√≥ th·ªÉ b·ªã hi·ªÉu nh∆∞ UTC
        function parseDateString(dateStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            return new Date(year, month - 1, day);
        }
        
        // Helper functions
        function formatDate(date) {
            if (!date) return 'N/A';
            const d = new Date(date);
            return `${d.getDate().toString().padStart(2, '0')}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getFullYear()}`;
        }
        
        function getDayName(date) {
            const days = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];
            return days[new Date(date).getDay()];
        }
        
        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        }
        
        function daysInMonth(year, month) {
            return new Date(year, month + 1, 0).getDate();
        }
        
        // Current filter state
        let currentFilter = 'all';
        
        // Logging
        function log(message, type = 'info') {
            const logEl = document.getElementById('testLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.setAttribute('data-type', type);
            
            if (type === 'pass') entry.classList.add('test-pass');
            else if (type === 'fail') entry.classList.add('test-fail');
            else if (type === 'warn') entry.classList.add('test-warn');
            else if (type === 'section') entry.classList.add('test-section');
            else entry.classList.add('test-info');
            
            // Apply current filter
            if (currentFilter !== 'all' && currentFilter !== type) {
                entry.classList.add('hidden');
            }
            
            const icons = { pass: '‚úÖ', fail: '‚ùå', warn: '‚ö†Ô∏è', info: '‚ÑπÔ∏è', section: 'üìå' };
            entry.innerHTML = `${icons[type] || '‚ÑπÔ∏è'} ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        // Filter log entries
        function filterLog(filterType) {
            currentFilter = filterType;
            const entries = document.querySelectorAll('#testLog .log-entry');
            
            entries.forEach(entry => {
                const entryType = entry.getAttribute('data-type');
                
                if (filterType === 'all') {
                    // Show all entries
                    entry.classList.remove('hidden');
                } else if (filterType === entryType) {
                    // Show matching entries
                    entry.classList.remove('hidden');
                } else if (entryType === 'section') {
                    // Always show section headers for context
                    entry.classList.remove('hidden');
                } else {
                    // Hide non-matching entries
                    entry.classList.add('hidden');
                }
            });
            
            // Update active button state
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = {
                'all': 'btnAll',
                'pass': 'btnPass',
                'fail': 'btnFail',
                'warn': 'btnWarn'
            };
            
            if (activeBtn[filterType]) {
                document.getElementById(activeBtn[filterType]).classList.add('active');
            }
            
            // Update filtered count display
            updateFilteredCount(filterType);
        }
        
        // Show filtered count in progress area
        function updateFilteredCount(filterType) {
            if (filterType === 'all') {
                document.getElementById('testProgress').textContent = 'Hi·ªÉn th·ªã t·∫•t c·∫£';
                return;
            }
            
            const totalCount = document.querySelectorAll(`#testLog .log-entry[data-type="${filterType}"]`).length;
            const labels = { pass: '‚úÖ Passed', fail: '‚ùå Failed', warn: '‚ö†Ô∏è Warnings' };
            document.getElementById('testProgress').textContent = `ƒêang l·ªçc: ${totalCount} ${labels[filterType] || filterType}`;
        }
        
        function updateStats() {
            document.getElementById('totalTests').textContent = stats.total;
            document.getElementById('passedTests').textContent = stats.passed;
            document.getElementById('failedTests').textContent = stats.failed;
            document.getElementById('warnTests').textContent = stats.warnings;
        }
        
        function clearLog() {
            document.getElementById('testLog').innerHTML = '';
            stats = { total: 0, passed: 0, failed: 0, warnings: 0 };
            updateStats();
            
            // Reset filter to 'all'
            currentFilter = 'all';
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btnAll').classList.add('active');
            document.getElementById('testProgress').textContent = '';
        }
        
        function assert(condition, message, warnOnly = false) {
            stats.total++;
            if (condition) {
                stats.passed++;
                log(message, 'pass');
                return true;
            } else {
                if (warnOnly) {
                    stats.warnings++;
                    log(message, 'warn');
                } else {
                    stats.failed++;
                    log(message, 'fail');
                }
                return false;
            }
        }
        
        // ============================================================
        // A. TEST: Date & ISO-Key (Timezone Safety)
        // ============================================================
        
        function testDateAndISOKey() {
            log('‚ïê‚ïê‚ïê A. DATE & ISO-KEY (Timezone Safety) ‚ïê‚ïê‚ïê', 'section');
            
            // Test 1: toISODate v·ªõi ng√†y cu·ªëi th√°ng
            const march31 = new Date(2024, 2, 31); // March 31, 2024
            assert(toISODate(march31) === "2024-03-31",
                `toISODate(new Date(2024,2,31)) === "2024-03-31" ‚Üí ${toISODate(march31)}`);
            
            // Test 2: toISODate v·ªõi ng√†y ƒë·∫ßu th√°ng
            const jan1 = new Date(2024, 0, 1);
            assert(toISODate(jan1) === "2024-01-01",
                `toISODate(new Date(2024,0,1)) === "2024-01-01" ‚Üí ${toISODate(jan1)}`);
            
            // Test 3: toISODate v·ªõi nƒÉm nhu·∫≠n 29/2
            const feb29 = new Date(2024, 1, 29);
            assert(toISODate(feb29) === "2024-02-29",
                `toISODate(new Date(2024,1,29)) === "2024-02-29" ‚Üí ${toISODate(feb29)}`);
            
            // Test 4: parseDateString round-trip
            const testDateStr = "2024-03-31";
            const parsed = parseDateString(testDateStr);
            const roundTrip = toISODate(parsed);
            assert(roundTrip === testDateStr,
                `parseDateString("2024-03-31") round-trip ‚Üí ${roundTrip}`);
            
            // Test 5: parseDateString kh√¥ng d√πng UTC
            const parsed2 = parseDateString("2024-12-31");
            assert(parsed2.getDate() === 31 && parsed2.getMonth() === 11,
                `parseDateString("2024-12-31").getDate() === 31, getMonth() === 11`);
            
            // Test 6: Consistency across different dates
            const testDates = [
                "2024-01-01", "2024-02-29", "2024-06-15", 
                "2024-12-31", "2025-03-01", "2100-02-28"
            ];
            let allPass = true;
            for (const dateStr of testDates) {
                const d = parseDateString(dateStr);
                if (toISODate(d) !== dateStr) {
                    allPass = false;
                    log(`Round-trip failed for ${dateStr} ‚Üí ${toISODate(d)}`, 'fail');
                    stats.failed++;
                }
            }
            if (allPass) {
                stats.total++;
                stats.passed++;
                log(`T·∫•t c·∫£ ${testDates.length} date strings round-trip th√†nh c√¥ng`, 'pass');
            }
        }
        
        // ============================================================
        // B. TEST: Schema Validation (Data Integrity)
        // ============================================================
        
        function testSchemaValidation(year) {
            log(`‚ïê‚ïê‚ïê B. SCHEMA VALIDATION - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            const litData = getLiturgicalData(year);
            const totalDays = isLeapYear(year) ? 366 : 365;
            let schemaErrors = 0;
            let sampleErrors = [];
            
            // Ki·ªÉm tra t·∫•t c·∫£ 365/366 ng√†y trong nƒÉm
            for (let month = 0; month < 12; month++) {
                const daysInM = daysInMonth(year, month);
                for (let day = 1; day <= daysInM; day++) {
                    const date = new Date(year, month, day);
                    const info = getDayInfo(date, litData);
                    
                    // Ki·ªÉm tra c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
                    const requiredFields = ['season', 'color', 'rankCode'];
                    for (const field of requiredFields) {
                        if (info[field] === undefined || info[field] === null) {
                            schemaErrors++;
                            if (sampleErrors.length < 5) {
                                sampleErrors.push(`${formatDate(date)}: thi·∫øu tr∆∞·ªùng "${field}"`);
                            }
                        }
                    }
                    
                    // Validate rank enum
                    if (info.rankCode && !VALID_RANKS.includes(info.rankCode)) {
                        schemaErrors++;
                        if (sampleErrors.length < 5) {
                            sampleErrors.push(`${formatDate(date)}: rankCode "${info.rankCode}" kh√¥ng h·ª£p l·ªá`);
                        }
                    }
                    
                    // Validate color enum
                    if (info.color && !VALID_COLORS.includes(info.color)) {
                        schemaErrors++;
                        if (sampleErrors.length < 5) {
                            sampleErrors.push(`${formatDate(date)}: color "${info.color}" kh√¥ng h·ª£p l·ªá`);
                        }
                    }
                    
                    // Validate season enum
                    if (info.season && !VALID_SEASONS.includes(info.season)) {
                        schemaErrors++;
                        if (sampleErrors.length < 5) {
                            sampleErrors.push(`${formatDate(date)}: season "${info.season}" kh√¥ng h·ª£p l·ªá`);
                        }
                    }
                }
            }
            
            if (schemaErrors === 0) {
                stats.total++;
                stats.passed++;
                log(`[${year}] T·∫•t c·∫£ ${totalDays} ng√†y ƒë·ªÅu ƒë·∫°t schema validation`, 'pass');
            } else {
                stats.total++;
                stats.failed++;
                log(`[${year}] Schema errors: ${schemaErrors}`, 'fail');
                sampleErrors.forEach(err => log(`  ‚Üí ${err}`, 'fail'));
            }
            
            // Test saints array lu√¥n l√† array
            const randomDate = new Date(year, 5, 15);
            const randomInfo = getDayInfo(randomDate, litData);
            assert(Array.isArray(randomInfo.saints),
                `[${year}] getDayInfo().saints l√† Array`);
            
            // Test commemorations lu√¥n l√† array  
            assert(Array.isArray(randomInfo.commemorations),
                `[${year}] getDayInfo().commemorations l√† Array`);
        }
        
        // ============================================================
        // C. TEST: Nghi·ªáp v·ª• Ph·ª•ng v·ª• C∆° b·∫£n
        // ============================================================
        
        function testLiturgicalBusiness(year) {
            log(`‚ïê‚ïê‚ïê C. NGHI·ªÜP V·ª§ PH·ª§NG V·ª§ C∆† B·∫¢N - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            const litData = getLiturgicalData(year);
            
            // C1. Ki·ªÉm tra ng√†y 1/1 - ƒê·ª©c M·∫π l√† M·∫π Thi√™n Ch√∫a
            const jan1 = new Date(year, 0, 1);
            const jan1Info = getDayInfo(jan1, litData);
            
            const jan1HasMary = jan1Info.special?.includes('MARIA') || 
                               jan1Info.special?.includes('M·∫π Thi√™n Ch√∫a') ||
                               jan1Info.saints?.some(s => s.name?.includes('MARIA'));
            assert(jan1HasMary,
                `[${year}] 01/01: ƒê·ª©c M·∫π l√† M·∫π Thi√™n Ch√∫a - special="${jan1Info.special}"`);
            
            assert(jan1Info.color === 'bg-lit-white',
                `[${year}] 01/01: color = WHITE ‚Üí ${jan1Info.color}`);
            
            // C2. Ki·ªÉm tra L·ªÖ Tro - Th·ª© T∆∞, m√†u t√≠m
            if (!litData.ashWednesdayTransferred) {
                const ashInfo = getDayInfo(litData.ashWednesday, litData);
                assert(ashInfo.special?.includes('Tro'),
                    `[${year}] L·ªÖ Tro (${formatDate(litData.ashWednesday)}): "${ashInfo.special}" ch·ª©a "Tro"`);
                assert(ashInfo.color === 'bg-lit-purple',
                    `[${year}] L·ªÖ Tro: color = PURPLE ‚Üí ${ashInfo.color}`);
                assert(ashInfo.season === 'M√πa Chay',
                    `[${year}] L·ªÖ Tro: season = M√πa Chay ‚Üí ${ashInfo.season}`);
            } else {
                // L·ªÖ Tro b·ªã d·ªùi: ng√†y g·ªëc c√≥ th·ªÉ tr√πng T·∫øt (∆∞u ti√™n T·∫øt), ng√†y c·ª≠ h√†nh ph·∫£i c√≥ "L·ªÖ Tro"
                const ashOriginal = getDayInfo(litData.ashWednesday, litData);
                const ashCelebration = getDayInfo(litData.ashWednesdayCelebration, litData);
                assert(ashCelebration.special?.includes('Tro'),
                    `[${year}] L·ªÖ Tro (d·ªùi) (${formatDate(litData.ashWednesdayCelebration)}): "${ashCelebration.special}" ch·ª©a "Tro"`);
                assert(ashCelebration.color === 'bg-lit-purple',
                    `[${year}] L·ªÖ Tro (d·ªùi): color = PURPLE ‚Üí ${ashCelebration.color}`);
                // Ng√†y g·ªëc c√≥ th·ªÉ l√† T·∫øt
                if (ashOriginal.special && ashOriginal.special.includes('T·∫æT')) {
                    assert(true, `[${year}] Ng√†y L·ªÖ Tro g·ªëc (${formatDate(litData.ashWednesday)}) ∆∞u ti√™n T·∫øt: "${ashOriginal.special}"`);
                }
            }
            
            // C3. Ki·ªÉm tra Ph·ª•c Sinh - m√†u tr·∫Øng
            const easterInfo = getDayInfo(litData.easter, litData);
            assert(easterInfo.special?.includes('Ph·ª•c Sinh'),
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}): "${easterInfo.special}" ch·ª©a "Ph·ª•c Sinh"`);
            assert(easterInfo.color === 'bg-lit-white',
                `[${year}] Ph·ª•c Sinh: color = WHITE ‚Üí ${easterInfo.color}`);
            assert(easterInfo.rankCode === 'TRONG',
                `[${year}] Ph·ª•c Sinh: rank = TRONG ‚Üí ${easterInfo.rankCode}`);
            
            // C4. Ki·ªÉm tra Th·ª© S√°u Tu·∫ßn Th√°nh - m√†u ƒë·ªè (kh√¥ng ph·∫£i t√≠m!)
            const goodFridayInfo = getDayInfo(litData.goodFriday, litData);
            assert(goodFridayInfo.color === 'bg-lit-red',
                `[${year}] Good Friday: color = RED (kh√¥ng ph·∫£i t√≠m!) ‚Üí ${goodFridayInfo.color}`);
            
            // C5. Ki·ªÉm tra Gi√°ng Sinh 25/12
            const christmas = new Date(year, 11, 25);
            const xmasInfo = getDayInfo(christmas, litData);
            assert(xmasInfo.season === 'M√πa Gi√°ng Sinh',
                `[${year}] 25/12: season = M√πa Gi√°ng Sinh ‚Üí ${xmasInfo.season}`);
            assert(xmasInfo.color === 'bg-lit-white',
                `[${year}] 25/12: color = WHITE ‚Üí ${xmasInfo.color}`);
            
            // C6. Ki·ªÉm tra M√πa V·ªçng - m√†u t√≠m
            const adventSundayInfo = getDayInfo(litData.adventStart, litData);
            assert(adventSundayInfo.color === 'bg-lit-purple',
                `[${year}] CN I M√πa V·ªçng: color = PURPLE ‚Üí ${adventSundayInfo.color}`);
            assert(adventSundayInfo.season === 'M√πa V·ªçng',
                `[${year}] CN I M√πa V·ªçng: season = M√πa V·ªçng ‚Üí ${adventSundayInfo.season}`);
        }
        
        // ============================================================
        // D. TEST: Month Grid Correctness
        // ============================================================
        
        function testMonthGrid(year) {
            log(`‚ïê‚ïê‚ïê D. MONTH GRID CORRECTNESS - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            // D1. Th√°ng 2 nƒÉm nhu·∫≠n ph·∫£i c√≥ 29 ng√†y
            if (isLeapYear(year)) {
                const feb = daysInMonth(year, 1);
                assert(feb === 29,
                    `[${year}] Th√°ng 2 (nƒÉm nhu·∫≠n) c√≥ ${feb} ng√†y - expected 29`);
            } else {
                const feb = daysInMonth(year, 1);
                assert(feb === 28,
                    `[${year}] Th√°ng 2 (kh√¥ng nhu·∫≠n) c√≥ ${feb} ng√†y - expected 28`);
            }
            
            // D2. Th√°ng 4 ph·∫£i c√≥ 30 ng√†y
            const apr = daysInMonth(year, 3);
            assert(apr === 30,
                `[${year}] Th√°ng 4 c√≥ ${apr} ng√†y - expected 30`);
            
            // D3. Th√°ng 1 ph·∫£i c√≥ 31 ng√†y
            const jan = daysInMonth(year, 0);
            assert(jan === 31,
                `[${year}] Th√°ng 1 c√≥ ${jan} ng√†y - expected 31`);
            
            // D4. Ki·ªÉm tra t·∫•t c·∫£ th√°ng c√≥ s·ªë ng√†y ƒë√∫ng
            const expectedDays = [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            let allCorrect = true;
            for (let m = 0; m < 12; m++) {
                const actual = daysInMonth(year, m);
                if (actual !== expectedDays[m]) {
                    allCorrect = false;
                    log(`[${year}] Th√°ng ${m+1} c√≥ ${actual} ng√†y, expected ${expectedDays[m]}`, 'fail');
                    stats.failed++;
                }
            }
            if (allCorrect) {
                stats.total++;
                stats.passed++;
                log(`[${year}] T·∫•t c·∫£ 12 th√°ng c√≥ s·ªë ng√†y ƒë√∫ng`, 'pass');
            }
            
            // D5. Ki·ªÉm tra ng√†y trong th√°ng ƒëi t·ª´ 1..lastDay
            const litData = getLiturgicalData(year);
            for (let m = 0; m < 12; m++) {
                const lastDay = daysInMonth(year, m);
                for (let d = 1; d <= lastDay; d++) {
                    const date = new Date(year, m, d);
                    if (date.getDate() !== d || date.getMonth() !== m) {
                        stats.total++;
                        stats.failed++;
                        log(`[${year}] Date overflow: ${year}-${m+1}-${d} ‚Üí ${formatDate(date)}`, 'fail');
                        return;
                    }
                }
            }
            stats.total++;
            stats.passed++;
            log(`[${year}] T·∫•t c·∫£ ng√†y trong nƒÉm validate ƒë√∫ng`, 'pass');
        }
        
        // ============================================================
        // E. TEST: Regression - Ng√†y Quan Tr·ªçng
        // ============================================================
        
        function testRegressionImportantDates(year) {
            log(`‚ïê‚ïê‚ïê E. REGRESSION - NG√ÄY QUAN TR·ªåNG - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            const litData = getLiturgicalData(year);
            
            // E1. Ph·ª•c Sinh ph·∫£i n·∫±m trong 22/3 - 25/4
            const easterMonth = litData.easter.getMonth();
            const easterDate = litData.easter.getDate();
            const validEaster = (easterMonth === 2 && easterDate >= 22) || 
                               (easterMonth === 3 && easterDate <= 25);
            assert(validEaster,
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}) ‚àà [22/3 - 25/4]`);
            
            // E2. Ph·ª•c Sinh ph·∫£i l√† Ch√∫a Nh·∫≠t
            assert(litData.easter.getDay() === 0,
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E3. L·ªÖ Tro = Ph·ª•c Sinh - 46 ng√†y
            const ashToEaster = Math.round((litData.easter - litData.ashWednesday) / (24*60*60*1000));
            assert(ashToEaster === 46,
                `[${year}] L·ªÖ Tro c√°ch Ph·ª•c Sinh ${ashToEaster} ng√†y - expected 46`);
            
            // E4. L·ªÖ Tro ph·∫£i l√† Th·ª© T∆∞
            assert(litData.ashWednesday.getDay() === 3,
                `[${year}] L·ªÖ Tro (${formatDate(litData.ashWednesday)}) l√† Th·ª© T∆∞`);
            
            // E5. CN I M√πa V·ªçng ‚àà [27/11 - 03/12]
            const adventMonth = litData.adventStart.getMonth();
            const adventDate = litData.adventStart.getDate();
            const validAdvent = (adventMonth === 10 && adventDate >= 27) || 
                               (adventMonth === 11 && adventDate <= 3);
            assert(validAdvent,
                `[${year}] CN I M√πa V·ªçng (${formatDate(litData.adventStart)}) ‚àà [27/11 - 03/12]`);
            
            // E6. CN I M√πa V·ªçng ph·∫£i l√† Ch√∫a Nh·∫≠t
            assert(litData.adventStart.getDay() === 0,
                `[${year}] CN I M√πa V·ªçng (${formatDate(litData.adventStart)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E7. ThƒÉng Thi√™n = Ph·ª•c Sinh + 39 ng√†y (Th·ª© NƒÉm truy·ªÅn th·ªëng VN)
            const ascensionDiff = Math.round((litData.ascension - litData.easter) / (24*60*60*1000));
            assert(ascensionDiff === 39,
                `[${year}] ThƒÉng Thi√™n c√°ch Ph·ª•c Sinh ${ascensionDiff} ng√†y - expected 39`);
            
            // E8. ThƒÉng Thi√™n ph·∫£i l√† Th·ª© NƒÉm
            assert(litData.ascension.getDay() === 4,
                `[${year}] ThƒÉng Thi√™n (${formatDate(litData.ascension)}) l√† Th·ª© NƒÉm`);
            
            // E9. Hi·ªán Xu·ªëng = Ph·ª•c Sinh + 49 ng√†y
            const pentecostDiff = Math.round((litData.pentecost - litData.easter) / (24*60*60*1000));
            assert(pentecostDiff === 49,
                `[${year}] Hi·ªán Xu·ªëng c√°ch Ph·ª•c Sinh ${pentecostDiff} ng√†y - expected 49`);
            
            // E10. Hi·ªán Xu·ªëng ph·∫£i l√† Ch√∫a Nh·∫≠t
            assert(litData.pentecost.getDay() === 0,
                `[${year}] Hi·ªán Xu·ªëng (${formatDate(litData.pentecost)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E11. Hi·ªÉn Linh ‚àà [02/01 - 08/01] v√† l√† Ch√∫a Nh·∫≠t
            const epiphanyMonth = litData.epiphany.getMonth();
            const epiphanyDate = litData.epiphany.getDate();
            const validEpiphany = epiphanyMonth === 0 && epiphanyDate >= 2 && epiphanyDate <= 8;
            assert(validEpiphany,
                `[${year}] Hi·ªÉn Linh (${formatDate(litData.epiphany)}) ‚àà [02/01 - 08/01]`);
            assert(litData.epiphany.getDay() === 0,
                `[${year}] Hi·ªÉn Linh (${formatDate(litData.epiphany)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E12. Ch√∫a Kit√¥ Vua = CN I M√πa V·ªçng - 7 ng√†y
            const christKingDiff = Math.round((litData.adventStart - litData.christKing) / (24*60*60*1000));
            assert(christKingDiff === 7,
                `[${year}] Ch√∫a Kit√¥ Vua c√°ch CN I M√πa V·ªçng ${christKingDiff} ng√†y - expected 7`);
        }
        
        // ============================================================
        // EXISTING TEST FUNCTIONS (Easter, Epiphany, Lent, Advent, Tet)
        // ============================================================
        
        function testEaster(year) {
            log(`--- Test Easter nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            const easterDay = litData.easter.getDay();
            assert(easterDay === 0, 
                `[${year}] Easter (${formatDate(litData.easter)}) l√† ${getDayName(litData.easter)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            
            const easterMonth = litData.easter.getMonth();
            const easterDate = litData.easter.getDate();
            const validRange = (easterMonth === 2 && easterDate >= 22) || 
                              (easterMonth === 3 && easterDate <= 25);
            assert(validRange,
                `[${year}] Easter (${formatDate(litData.easter)}) trong kho·∫£ng 22/3 - 25/4`);
            
            const ashDay = litData.ashWednesday.getDay();
            assert(ashDay === 3,
                `[${year}] Ash Wednesday (${formatDate(litData.ashWednesday)}) l√† ${getDayName(litData.ashWednesday)} - ph·∫£i l√† Th·ª© T∆∞`);
            
            const daysDiff = Math.round((litData.easter - litData.ashWednesday) / (24*60*60*1000));
            assert(daysDiff === 46,
                `[${year}] Ash Wednesday c√°ch Easter ${daysDiff} ng√†y - ph·∫£i l√† 46 ng√†y`);
            
            const palmDiff = Math.round((litData.easter - litData.palmSunday) / (24*60*60*1000));
            assert(palmDiff === 7,
                `[${year}] Palm Sunday (${formatDate(litData.palmSunday)}) c√°ch Easter ${palmDiff} ng√†y - ph·∫£i l√† 7 ng√†y`);
            
            const goodFridayDiff = Math.round((litData.easter - litData.goodFriday) / (24*60*60*1000));
            assert(goodFridayDiff === 2,
                `[${year}] Good Friday (${formatDate(litData.goodFriday)}) c√°ch Easter ${goodFridayDiff} ng√†y - ph·∫£i l√† 2 ng√†y`);
            
            const pentecostDiff = Math.round((litData.pentecost - litData.easter) / (24*60*60*1000));
            assert(pentecostDiff === 49,
                `[${year}] Pentecost (${formatDate(litData.pentecost)}) c√°ch Easter ${pentecostDiff} ng√†y - ph·∫£i l√† 49 ng√†y`);
            
            const ascensionDiff = Math.round((litData.ascension - litData.easter) / (24*60*60*1000));
            assert(ascensionDiff === 39,
                `[${year}] Ascension (${formatDate(litData.ascension)}) c√°ch Easter ${ascensionDiff} ng√†y - ph·∫£i l√† 39 ng√†y`);
            
            const ascensionDay = litData.ascension.getDay();
            assert(ascensionDay === 4,
                `[${year}] Ascension (${formatDate(litData.ascension)}) l√† ${getDayName(litData.ascension)} - ph·∫£i l√† Th·ª© NƒÉm`);
        }
        
        function testEpiphanyAndBaptism(year) {
            log(`--- Test Hi·ªÉn Linh & Ph√©p R·ª≠a nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            const epiphanyDay = litData.epiphany.getDay();
            assert(epiphanyDay === 0,
                `[${year}] Epiphany (${formatDate(litData.epiphany)}) l√† ${getDayName(litData.epiphany)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            
            const epiphanyDate = litData.epiphany.getDate();
            const epiphanyMonth = litData.epiphany.getMonth();
            const validEpiphany = epiphanyMonth === 0 && epiphanyDate >= 2 && epiphanyDate <= 8;
            assert(validEpiphany,
                `[${year}] Epiphany (${formatDate(litData.epiphany)}) trong kho·∫£ng 2/1 - 8/1`);
            
            const baptismAfterEpiphany = litData.baptismLord > litData.epiphany;
            assert(baptismAfterEpiphany,
                `[${year}] Baptism (${formatDate(litData.baptismLord)}) sau Epiphany (${formatDate(litData.epiphany)})`);
            
            if (epiphanyDate === 7 || epiphanyDate === 8) {
                const daysDiff = Math.round((litData.baptismLord - litData.epiphany) / (24*60*60*1000));
                assert(daysDiff === 1,
                    `[${year}] Epiphany = ${epiphanyDate}/1 ‚Üí Baptism ng√†y h√¥m sau (${formatDate(litData.baptismLord)}) - diff=${daysDiff}`);
                
                const baptismDay = litData.baptismLord.getDay();
                assert(baptismDay === 1,
                    `[${year}] Baptism (${formatDate(litData.baptismLord)}) l√† ${getDayName(litData.baptismLord)} - ph·∫£i l√† Th·ª© Hai`);
            } else {
                const baptismDay = litData.baptismLord.getDay();
                assert(baptismDay === 0,
                    `[${year}] Baptism (${formatDate(litData.baptismLord)}) l√† ${getDayName(litData.baptismLord)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            }
            
            const dayAfterEpiphany = new Date(litData.epiphany);
            dayAfterEpiphany.setDate(dayAfterEpiphany.getDate() + 1);
            
            if (dayAfterEpiphany < litData.baptismLord) {
                const info = getDayInfo(dayAfterEpiphany, litData);
                const hasSolemnOrFeast = info.saints.some(s => s.rank === 'TRONG' || s.rank === 'KINH');
                
                if (!hasSolemnOrFeast) {
                    assert(info.special && info.special.includes('sau l·ªÖ Hi·ªÉn Linh'),
                        `[${year}] Ng√†y ${formatDate(dayAfterEpiphany)}: "${info.special}" - expected ch·ª©a "sau l·ªÖ Hi·ªÉn Linh"`);
                }
                
                const code = getLiturgicalDayCode(dayAfterEpiphany, litData);
                assert(code.startsWith('600'),
                    `[${year}] M√£ ng√†y ${formatDate(dayAfterEpiphany)}: ${code} - expected b·∫Øt ƒë·∫ßu v·ªõi "600"`);
            }
            
            const baptismCode = getLiturgicalDayCode(litData.baptismLord, litData);
            assert(baptismCode === '5010',
                `[${year}] M√£ Baptism: ${baptismCode} - expected "5010"`);
        }
        
        function testLent(year) {
            log(`--- Test M√πa Chay nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            if (!litData.ashWednesdayTransferred) {
                const ashInfo = getDayInfo(litData.ashWednesday, litData);
                assert(ashInfo.special && ashInfo.special.includes('Tro'),
                    `[${year}] Ash Wednesday (${formatDate(litData.ashWednesday)}): "${ashInfo.special}" - expected ch·ª©a "Tro"`);
                
                const ashCode = getLiturgicalDayCode(litData.ashWednesday, litData);
                assert(ashCode === '3004',
                    `[${year}] M√£ Ash Wednesday: ${ashCode} - expected "3004"`);
            } else {
                log(`[${year}] ‚ö†Ô∏è L·ªÖ Tro b·ªã d·ªùi do tr√πng T·∫øt: ${litData.ashWednesdayTransferNote}`, 'warn');
                stats.warnings++;
            }
            
            const palmInfo = getDayInfo(litData.palmSunday, litData);
            assert(palmInfo.special && palmInfo.special.includes('L√°'),
                `[${year}] Palm Sunday (${formatDate(litData.palmSunday)}): "${palmInfo.special}"`, true);
            
            const goodFridayInfo = getDayInfo(litData.goodFriday, litData);
            assert(goodFridayInfo.color.includes('red'),
                `[${year}] Good Friday (${formatDate(litData.goodFriday)}): color="${goodFridayInfo.color}" - expected "bg-lit-red"`);
            
            assert(goodFridayInfo.special && goodFridayInfo.special.includes('Th·ª© S√°u Tu·∫ßn Th√°nh'),
                `[${year}] Good Friday special: "${goodFridayInfo.special}" - expected ch·ª©a "Th·ª© S√°u Tu·∫ßn Th√°nh"`);
        }
        
        function testAdvent(year) {
            log(`--- Test M√πa V·ªçng nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            const adventDay = litData.adventStart.getDay();
            assert(adventDay === 0,
                `[${year}] Advent Start (${formatDate(litData.adventStart)}) l√† ${getDayName(litData.adventStart)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            
            const adventDate = litData.adventStart.getDate();
            const adventMonth = litData.adventStart.getMonth();
            const validAdvent = (adventMonth === 10 && adventDate >= 27) || 
                               (adventMonth === 11 && adventDate <= 3);
            assert(validAdvent,
                `[${year}] Advent Start (${formatDate(litData.adventStart)}) trong kho·∫£ng 27/11 - 03/12`);
            
            const christKingDiff = Math.round((litData.adventStart - litData.christKing) / (24*60*60*1000));
            assert(christKingDiff === 7,
                `[${year}] Christ King (${formatDate(litData.christKing)}) c√°ch Advent ${christKingDiff} ng√†y - ph·∫£i l√† 7 ng√†y`);
            
            assert(litData.christmas.getMonth() === 11 && litData.christmas.getDate() === 25,
                `[${year}] Christmas: ${formatDate(litData.christmas)} - expected 25/12`);
        }
        
        function testTet(year) {
            log(`--- Test T·∫øt nƒÉm ${year} ---`, 'info');
            
            if (typeof LUNAR_CALENDAR === 'undefined') {
                log(`[${year}] LUNAR_CALENDAR kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a`, 'warn');
                stats.warnings++;
                return;
            }
            
            let tetDate = null;
            for (let month = 0; month <= 1; month++) {
                for (let day = 1; day <= 31; day++) {
                    try {
                        const date = new Date(year, month, day);
                        if (date.getMonth() !== month) continue;
                        
                        const lunar = LUNAR_CALENDAR.getLunarDate(date);
                        if (lunar && lunar.day === 1 && lunar.month === 1) {
                            tetDate = date;
                            break;
                        }
                    } catch (e) {}
                }
                if (tetDate) break;
            }
            
            if (tetDate) {
                log(`[${year}] M√πng 1 T·∫øt: ${formatDate(tetDate)} (${getDayName(tetDate)})`, 'info');
                
                if (typeof getTetEvent === 'function') {
                    const tetEvent = getTetEvent(tetDate);
                    assert(tetEvent !== null,
                        `[${year}] getTetEvent(${formatDate(tetDate)}) nh·∫≠n di·ªán M√πng 1 T·∫øt`);
                }
                
                const litData = getLiturgicalData(year);
                const ashTime = litData.ashWednesday.getTime();
                const tetTime = tetDate.getTime();
                const daysDiff = Math.abs(ashTime - tetTime) / (24*60*60*1000);
                
                if (daysDiff <= 3) {
                    log(`[${year}] ‚ö†Ô∏è T·∫øt g·∫ßn L·ªÖ Tro! Kho·∫£ng c√°ch: ${daysDiff} ng√†y`, 'warn');
                    stats.warnings++;
                    
                    if (litData.ashWednesdayTransferred) {
                        assert(true, `[${year}] L·ªÖ Tro ƒë√£ ƒë∆∞·ª£c d·ªùi ƒë√∫ng c√°ch`);
                    }
                }
            } else {
                log(`[${year}] Kh√¥ng t√¨m th·∫•y ng√†y M√πng 1 T·∫øt`, 'warn');
                stats.warnings++;
            }
        }
        
        // ============================================================
        // TEST: Ki·ªÉm Tra Format M√£ Code T·ª´ getLiturgicalDayCode()
        // ============================================================
        
        function testControllerCodeFormat(year) {
            log(`‚ïê‚ïê‚ïê ‚úÖ KI·ªÇM TRA FORMAT M√É CODE T·ª™ CONTROLLER - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            if (typeof getLiturgicalDayCode === 'undefined') {
                log('‚ùå getLiturgicalDayCode kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a', 'fail');
                stats.failed++;
                stats.total++;
                return;
            }
            
            const litData = getLiturgicalData(year);
            if (!litData) {
                log(`‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu ph·ª•ng v·ª• cho nƒÉm ${year}`, 'fail');
                stats.failed++;
                stats.total++;
                return;
            }
            
            let invalidCodes = [];
            let validCodes = [];
            let testCases = [];
            
            // H√†m validate format (d√πng l·∫°i t·ª´ testReadingDataCodeFormat)
            function validateCodeFormat(code) {
                const codeStr = String(code);
                const codeNum = parseInt(code);
                
                // 1. T·∫øt: 70001-70003
                if (codeNum >= 70001 && codeNum <= 70003) {
                    return { valid: true, type: 'T·∫øt', format: '7000D' };
                }
                
                // 2. Sanctoral: 7DDMM (5 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 7)
                if (codeStr.length === 5 && codeStr.startsWith('7') && codeNum >= 70000 && codeNum < 80000) {
                    const dd = parseInt(codeStr.substring(1, 3));
                    const mm = parseInt(codeStr.substring(3, 5));
                    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {
                        return { valid: true, type: 'Sanctoral', format: '7DDMM' };
                    }
                }
                
                // 3. M√πa Gi√°ng Sinh: 2DDMM (5 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 2)
                if (codeStr.length === 5 && codeStr.startsWith('2') && codeNum >= 20000 && codeNum < 30000) {
                    const dd = parseInt(codeStr.substring(1, 3));
                    const mm = parseInt(codeStr.substring(3, 5));
                    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {
                        return { valid: true, type: 'M√πa Gi√°ng Sinh', format: '2DDMM' };
                    }
                }
                
                // 4. M√πa Th∆∞·ªùng Ni√™n: 5TTD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 5)
                // Ngo·∫°i l·ªá: 5001-5004, 5010, 5340
                if (codeNum === 5001 || codeNum === 5002 || codeNum === 5003 || codeNum === 5004 || codeNum === 5010 || codeNum === 5340) {
                    return { valid: true, type: 'M√πa Th∆∞·ªùng Ni√™n (L·ªÖ ƒë·∫∑c bi·ªát)', format: '5xxx' };
                }
                if (codeStr.length === 4 && codeStr.startsWith('5') && codeNum >= 5000 && codeNum < 6000) {
                    const week = parseInt(codeStr.substring(1, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 34 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa Th∆∞·ªùng Ni√™n', format: '5TTD' };
                    }
                }
                
                // 5. M√πa Ph·ª•c Sinh: 40TD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 4)
                // Ngo·∫°i l·ªá: 4080, 4089
                if (codeNum === 4080 || codeNum === 4089) {
                    return { valid: true, type: 'M√πa Ph·ª•c Sinh (L·ªÖ ƒë·∫∑c bi·ªát)', format: '408x' };
                }
                if (codeStr.length === 4 && codeStr.startsWith('4') && codeNum >= 4000 && codeNum < 5000) {
                    const week = parseInt(codeStr.substring(2, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 7 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa Ph·ª•c Sinh', format: '40TD' };
                    }
                }
                
                // 6. M√πa Chay: 30TD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 3)
                // Ngo·∫°i l·ªá: 3004-3007, 3060-3066
                if (codeNum >= 3004 && codeNum <= 3007) {
                    return { valid: true, type: 'M√πa Chay (L·ªÖ Tro)', format: '300x' };
                }
                if (codeNum >= 3060 && codeNum <= 3066) {
                    return { valid: true, type: 'M√πa Chay (Tu·∫ßn Th√°nh)', format: '306D' };
                }
                if (codeStr.length === 4 && codeStr.startsWith('3') && codeNum >= 3000 && codeNum < 4000) {
                    const week = parseInt(codeStr.substring(2, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 5 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa Chay', format: '30TD' };
                    }
                }
                
                // 7. M√πa V·ªçng: 10TD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 1)
                if (codeStr.length === 4 && codeStr.startsWith('1') && codeNum >= 1000 && codeNum < 2000) {
                    const week = parseInt(codeStr.substring(2, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 4 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa V·ªçng', format: '10TD' };
                    }
                }
                
                // 8. C√°c m√£ ƒë·∫∑c bi·ªát kh√°c: 2030, 6001-6006, 8441
                if (codeNum === 2030) {
                    return { valid: true, type: 'L·ªÖ Hi·ªÉn Linh', format: '2030' };
                }
                if (codeNum >= 6001 && codeNum <= 6006) {
                    return { valid: true, type: 'Sau L·ªÖ Hi·ªÉn Linh', format: '600x' };
                }
                if (codeNum === 8441) {
                    return { valid: true, type: 'Tr√°i Tim V√¥ Nhi·ªÖm M·∫π', format: '8441' };
                }
                
                return { valid: false, type: 'Kh√¥ng x√°c ƒë·ªãnh', format: 'N/A' };
            }
            
            // Test v·ªõi nhi·ªÅu ng√†y trong nƒÉm
            const testDates = [];
            
            // 1. C√°c ng√†y quan tr·ªçng
            if (litData.adventStart) testDates.push({ date: litData.adventStart, desc: 'CN I M√πa V·ªçng' });
            if (litData.christmas) testDates.push({ date: litData.christmas, desc: 'Gi√°ng Sinh' });
            if (litData.epiphany) testDates.push({ date: litData.epiphany, desc: 'Hi·ªÉn Linh' });
            if (litData.baptismLord) testDates.push({ date: litData.baptismLord, desc: 'Ch√∫a Gi√™su Ch·ªãu Ph√©p R·ª≠a' });
            if (litData.ashWednesday) testDates.push({ date: litData.ashWednesday, desc: 'L·ªÖ Tro' });
            if (litData.easter) testDates.push({ date: litData.easter, desc: 'Ph·ª•c Sinh' });
            if (litData.ascension) testDates.push({ date: litData.ascension, desc: 'ThƒÉng Thi√™n' });
            if (litData.pentecost) testDates.push({ date: litData.pentecost, desc: 'Hi·ªán Xu·ªëng' });
            if (litData.trinity) testDates.push({ date: litData.trinity, desc: 'Ba Ng√¥i' });
            if (litData.corpusChristi) testDates.push({ date: litData.corpusChristi, desc: 'M√¨nh M√°u Th√°nh' });
            if (litData.sacredHeart) testDates.push({ date: litData.sacredHeart, desc: 'Th√°nh T√¢m' });
            if (litData.christKing) testDates.push({ date: litData.christKing, desc: 'Ch√∫a Kit√¥ Vua' });
            
            // 2. C√°c ng√†y c·ªë ƒë·ªãnh quan tr·ªçng
            testDates.push({ date: new Date(year, 11, 17), desc: '17/12' });
            testDates.push({ date: new Date(year, 11, 24), desc: '24/12' });
            testDates.push({ date: new Date(year, 0, 1), desc: '01/01' });
            testDates.push({ date: new Date(year, 7, 15), desc: '15/08 - ƒê·ª©c M·∫π L√™n Tr·ªùi' });
            testDates.push({ date: new Date(year, 10, 24), desc: '24/11 - C√°c Th√°nh T·ª≠ ƒê·∫°o VN' });
            
            // 3. M·ªôt s·ªë ng√†y ng·∫´u nhi√™n trong c√°c m√πa
            for (let month = 0; month < 12; month++) {
                for (let day = 1; day <= 28; day += 7) {
                    const testDate = new Date(year, month, day);
                    if (testDate.getFullYear() === year) {
                        testDates.push({ date: testDate, desc: `Ng√†y ${day}/${month + 1}` });
                    }
                }
            }
            
            // Ki·ªÉm tra t·ª´ng ng√†y
            for (const testCase of testDates) {
                try {
                    const code = getLiturgicalDayCode(testCase.date, litData);
                    const validation = validateCodeFormat(code);
                    
                    if (validation.valid) {
                        validCodes.push({ date: testCase.date, code, desc: testCase.desc, ...validation });
                    } else {
                        invalidCodes.push({ date: testCase.date, code, desc: testCase.desc, ...validation });
                    }
                } catch (e) {
                    invalidCodes.push({ 
                        date: testCase.date, 
                        code: 'ERROR', 
                        desc: testCase.desc, 
                        error: e.message,
                        valid: false,
                        type: 'L·ªói',
                        format: 'N/A'
                    });
                }
            }
            
            // B√°o c√°o k·∫øt qu·∫£
            const totalTests = testDates.length;
            const passedTests = validCodes.length;
            const failedTests = invalidCodes.length;
            
            if (failedTests === 0) {
                stats.total++;
                stats.passed++;
                log(`‚úÖ T·∫•t c·∫£ ${totalTests} m√£ code ƒë·ªÅu ƒë√∫ng format`, 'pass');
            } else {
                stats.total++;
                stats.failed++;
                log(`‚ùå C√≥ ${failedTests} m√£ code kh√¥ng ƒë√∫ng format trong t·ªïng s·ªë ${totalTests} m√£`, 'fail');
                invalidCodes.slice(0, 20).forEach(item => {
                    const dateStr = formatDate(item.date);
                    log(`  ‚Üí ${dateStr} (${item.desc}): code="${item.code}" - ${item.type} (format: ${item.format})${item.error ? ' - ERROR: ' + item.error : ''}`, 'fail');
                });
                if (invalidCodes.length > 20) {
                    log(`  ... v√† ${invalidCodes.length - 20} m√£ kh√°c`, 'fail');
                }
            }
            
            // Th·ªëng k√™ theo lo·∫°i
            const statsByType = {};
            validCodes.forEach(item => {
                if (!statsByType[item.type]) {
                    statsByType[item.type] = 0;
                }
                statsByType[item.type]++;
            });
            
            log('', 'info');
            log('üìä Th·ªëng k√™ m√£ code theo lo·∫°i:', 'info');
            Object.entries(statsByType).sort((a, b) => b[1] - a[1]).forEach(([type, count]) => {
                log(`  - ${type}: ${count} m√£`, 'info');
            });
        }
        
        // ============================================================
        // TEST: Ki·ªÉm Tra Format M√£ Code Trong readingdata.js
        // ============================================================
        
        function testReadingDataCodeFormat() {
            log('‚ïê‚ïê‚ïê ‚úÖ KI·ªÇM TRA FORMAT M√É CODE TRONG readingdata.js ‚ïê‚ïê‚ïê', 'section');
            
            if (typeof READINGS_DATA === 'undefined' || !Array.isArray(READINGS_DATA)) {
                log('‚ùå READINGS_DATA kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ho·∫∑c kh√¥ng ph·∫£i array', 'fail');
                stats.failed++;
                stats.total++;
                return;
            }
            
            // L·∫•y t·∫•t c·∫£ c√°c m√£ code duy nh·∫•t
            const uniqueCodes = new Set(READINGS_DATA.map(r => r.code));
            const codeArray = Array.from(uniqueCodes).sort((a, b) => a - b);
            
            log(`T·ªïng s·ªë m√£ code duy nh·∫•t: ${codeArray.length}`, 'info');
            
            let invalidCodes = [];
            let validCodes = [];
            
            // H√†m ki·ªÉm tra format
            function validateCodeFormat(code) {
                const codeStr = String(code);
                const codeNum = parseInt(code);
                
                // 1. T·∫øt: 70001-70003
                if (codeNum >= 70001 && codeNum <= 70003) {
                    return { valid: true, type: 'T·∫øt', format: '7000D' };
                }
                
                // 2. Sanctoral: 7DDMM (5 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 7)
                if (codeStr.length === 5 && codeStr.startsWith('7') && codeNum >= 70000 && codeNum < 80000) {
                    const dd = parseInt(codeStr.substring(1, 3));
                    const mm = parseInt(codeStr.substring(3, 5));
                    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {
                        return { valid: true, type: 'Sanctoral', format: '7DDMM' };
                    }
                }
                
                // 3. M√πa Gi√°ng Sinh: 2DDMM (5 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 2)
                if (codeStr.length === 5 && codeStr.startsWith('2') && codeNum >= 20000 && codeNum < 30000) {
                    const dd = parseInt(codeStr.substring(1, 3));
                    const mm = parseInt(codeStr.substring(3, 5));
                    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {
                        return { valid: true, type: 'M√πa Gi√°ng Sinh', format: '2DDMM' };
                    }
                }
                
                // 4. M√πa Th∆∞·ªùng Ni√™n: 5TTD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 5)
                // Ngo·∫°i l·ªá: 5001-5004, 5010, 5340
                if (codeNum === 5001 || codeNum === 5002 || codeNum === 5003 || codeNum === 5004 || codeNum === 5010 || codeNum === 5340) {
                    return { valid: true, type: 'M√πa Th∆∞·ªùng Ni√™n (L·ªÖ ƒë·∫∑c bi·ªát)', format: '5xxx' };
                }
                if (codeStr.length === 4 && codeStr.startsWith('5') && codeNum >= 5000 && codeNum < 6000) {
                    const week = parseInt(codeStr.substring(1, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 34 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa Th∆∞·ªùng Ni√™n', format: '5TTD' };
                    }
                }
                
                // 5. M√πa Ph·ª•c Sinh: 40TD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 4)
                // Ngo·∫°i l·ªá: 4080, 4089
                if (codeNum === 4080 || codeNum === 4089) {
                    return { valid: true, type: 'M√πa Ph·ª•c Sinh (L·ªÖ ƒë·∫∑c bi·ªát)', format: '408x' };
                }
                if (codeStr.length === 4 && codeStr.startsWith('4') && codeNum >= 4000 && codeNum < 5000) {
                    const week = parseInt(codeStr.substring(2, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 7 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa Ph·ª•c Sinh', format: '40TD' };
                    }
                }
                
                // 6. M√πa Chay: 30TD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 3)
                // Ngo·∫°i l·ªá: 3004-3007, 3060-3066
                if (codeNum >= 3004 && codeNum <= 3007) {
                    return { valid: true, type: 'M√πa Chay (L·ªÖ Tro)', format: '300x' };
                }
                if (codeNum >= 3060 && codeNum <= 3066) {
                    return { valid: true, type: 'M√πa Chay (Tu·∫ßn Th√°nh)', format: '306D' };
                }
                if (codeStr.length === 4 && codeStr.startsWith('3') && codeNum >= 3000 && codeNum < 4000) {
                    const week = parseInt(codeStr.substring(2, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 5 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa Chay', format: '30TD' };
                    }
                }
                
                // 7. M√πa V·ªçng: 10TD (4 ch·ªØ s·ªë, b·∫Øt ƒë·∫ßu b·∫±ng 1)
                if (codeStr.length === 4 && codeStr.startsWith('1') && codeNum >= 1000 && codeNum < 2000) {
                    const week = parseInt(codeStr.substring(2, 3));
                    const day = parseInt(codeStr.substring(3, 4));
                    if (week >= 1 && week <= 4 && day >= 0 && day <= 6) {
                        return { valid: true, type: 'M√πa V·ªçng', format: '10TD' };
                    }
                }
                
                // 8. C√°c m√£ ƒë·∫∑c bi·ªát kh√°c: 2030, 6001-6006, 8441
                if (codeNum === 2030) {
                    return { valid: true, type: 'L·ªÖ Hi·ªÉn Linh', format: '2030' };
                }
                if (codeNum >= 6001 && codeNum <= 6006) {
                    return { valid: true, type: 'Sau L·ªÖ Hi·ªÉn Linh', format: '600x' };
                }
                if (codeNum === 8441) {
                    return { valid: true, type: 'Tr√°i Tim V√¥ Nhi·ªÖm M·∫π', format: '8441' };
                }
                
                return { valid: false, type: 'Kh√¥ng x√°c ƒë·ªãnh', format: 'N/A' };
            }
            
            // Ki·ªÉm tra t·ª´ng m√£
            for (const code of codeArray) {
                const validation = validateCodeFormat(code);
                if (validation.valid) {
                    validCodes.push({ code, ...validation });
                } else {
                    invalidCodes.push({ code, ...validation });
                }
            }
            
            // B√°o c√°o k·∫øt qu·∫£
            if (invalidCodes.length === 0) {
                stats.total++;
                stats.passed++;
                log(`‚úÖ T·∫•t c·∫£ ${codeArray.length} m√£ code ƒë·ªÅu ƒë√∫ng format`, 'pass');
            } else {
                stats.total++;
                stats.failed++;
                log(`‚ùå C√≥ ${invalidCodes.length} m√£ code kh√¥ng ƒë√∫ng format trong t·ªïng s·ªë ${codeArray.length} m√£`, 'fail');
                invalidCodes.slice(0, 20).forEach(item => {
                    log(`  ‚Üí M√£ ${item.code}: ${item.type} (format: ${item.format})`, 'fail');
                });
                if (invalidCodes.length > 20) {
                    log(`  ... v√† ${invalidCodes.length - 20} m√£ kh√°c`, 'fail');
                }
            }
            
            // Th·ªëng k√™ theo lo·∫°i
            const statsByType = {};
            validCodes.forEach(item => {
                if (!statsByType[item.type]) {
                    statsByType[item.type] = 0;
                }
                statsByType[item.type]++;
            });
            
            log('', 'info');
            log('üìä Th·ªëng k√™ m√£ code theo lo·∫°i:', 'info');
            Object.entries(statsByType).sort((a, b) => b[1] - a[1]).forEach(([type, count]) => {
                log(`  - ${type}: ${count} m√£`, 'info');
            });
            
            // Ki·ªÉm tra c√°c m√£ ƒë·∫∑c bi·ªát c√≥ t·ªìn t·∫°i kh√¥ng
            log('', 'info');
            log('üîç Ki·ªÉm tra c√°c m√£ ƒë·∫∑c bi·ªát:', 'info');
            const specialCodes = {
                '5001': 'Hi·ªán Xu·ªëng',
                '5002': 'Ba Ng√¥i',
                '5003': 'M√¨nh M√°u Th√°nh',
                '5004': 'Th√°nh T√¢m',
                '5010': 'Ch√∫a Gi√™su Ch·ªãu Ph√©p R·ª≠a',
                '5340': 'Ch√∫a Kit√¥ Vua',
                '2030': 'L·ªÖ Hi·ªÉn Linh',
                '4080': 'ThƒÉng Thi√™n',
                '4089': 'V·ªçng Hi·ªán Xu·ªëng',
                '8441': 'Tr√°i Tim V√¥ Nhi·ªÖm M·∫π',
                '70001': 'M√πng 1 T·∫øt',
                '70002': 'M√πng 2 T·∫øt',
                '70003': 'M√πng 3 T·∫øt'
            };
            
            for (const [code, name] of Object.entries(specialCodes)) {
                const exists = codeArray.includes(parseInt(code));
                if (exists) {
                    stats.total++;
                    stats.passed++;
                    log(`  ‚úÖ ${code} (${name}): C√≥ trong d·ªØ li·ªáu`, 'pass');
                } else {
                    stats.total++;
                    stats.warnings++;
                    log(`  ‚ö†Ô∏è ${code} (${name}): Kh√¥ng t√¨m th·∫•y trong d·ªØ li·ªáu`, 'warn');
                }
            }
        }
        
        // ============================================================
        // TEST: Quy T·∫Øc T·∫°o M√£ B√†i ƒê·ªçc (Reading Code Rules)
        // ============================================================
        
        function testReadingCodeRules(year) {
            log(`‚ïê‚ïê‚ïê üìñ QUY T·∫ÆC T·∫†O M√É B√ÄI ƒê·ªåC - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            const litData = getLiturgicalData(year);
            
            // Test 1: M√πa Th∆∞·ªùng Ni√™n (5TTD)
            // 5010: Ch√∫a Gi√™su Ch·ªãu Ph√©p R·ª≠a
            const baptismCode = getLiturgicalDayCode(litData.baptismLord, litData);
            assert(baptismCode === '5010',
                `[${year}] Ch√∫a Gi√™su Ch·ªãu Ph√©p R·ª≠a (${formatDate(litData.baptismLord)}): code="${baptismCode}" - expected "5010"`);
            
            // Test 2: M√πa Th∆∞·ªùng Ni√™n - T√¨m CN tu·∫ßn 10 (5100) trong nƒÉm
            let week10Sunday = null;
            const otStart = new Date(litData.baptismLord);
            otStart.setDate(otStart.getDate() + 1);
            const otEnd = new Date(litData.adventStart);
            
            for (let d = new Date(otStart); d < otEnd; d.setDate(d.getDate() + 1)) {
                if (d.getDay() !== 0) continue;
                const code = getLiturgicalDayCode(d, litData);
                if (code === '5100') {
                    week10Sunday = new Date(d);
                    break;
                }
            }
            
            if (week10Sunday) {
                assert(true, `[${year}] T√¨m ƒë∆∞·ª£c CN tu·∫ßn 10 TN: ${formatDate(week10Sunday)} (code=5100)`);
            } else {
                assert(false, `[${year}] Kh√¥ng t√¨m th·∫•y CN tu·∫ßn 10 TN (code=5100)`);
            }
            
            // Test 3: M√πa Th∆∞·ªùng Ni√™n - Th·ª© Ba tu·∫ßn 10 (5102)
            if (week10Sunday) {
                const week10Tuesday = new Date(week10Sunday);
                week10Tuesday.setDate(week10Tuesday.getDate() + 2);
                const week10TueCode = getLiturgicalDayCode(week10Tuesday, litData);
                assert(week10TueCode === '5102',
                    `[${year}] Th·ª© Ba tu·∫ßn 10 TN (${formatDate(week10Tuesday)}): code="${week10TueCode}" - expected "5102"`);
            }
            
            // Test 4: C√°c l·ªÖ tr·ªçng sau Hi·ªán Xu·ªëng
            // 5001: Hi·ªán Xu·ªëng
            const pentecostCode = getLiturgicalDayCode(litData.pentecost, litData);
            assert(pentecostCode === '5001',
                `[${year}] Hi·ªán Xu·ªëng (${formatDate(litData.pentecost)}): code="${pentecostCode}" - expected "5001"`);
            
            // 5002: Ba Ng√¥i
            if (litData.trinity) {
                const trinityCode = getLiturgicalDayCode(litData.trinity, litData);
                assert(trinityCode === '5002',
                    `[${year}] Ba Ng√¥i (${formatDate(litData.trinity)}): code="${trinityCode}" - expected "5002"`);
            }
            
            // 5003: M√¨nh M√°u Th√°nh
            if (litData.corpusChristi) {
                const corpusCode = getLiturgicalDayCode(litData.corpusChristi, litData);
                assert(corpusCode === '5003',
                    `[${year}] M√¨nh M√°u Th√°nh (${formatDate(litData.corpusChristi)}): code="${corpusCode}" - expected "5003"`);
            }
            
            // 5004: Th√°nh T√¢m
            if (litData.sacredHeart) {
                const sacredHeartCode = getLiturgicalDayCode(litData.sacredHeart, litData);
                assert(sacredHeartCode === '5004',
                    `[${year}] Th√°nh T√¢m (${formatDate(litData.sacredHeart)}): code="${sacredHeartCode}" - expected "5004"`);
            }
            
            // Test 5: M√πa V·ªçng (10TD)
            const advent1Code = getLiturgicalDayCode(litData.adventStart, litData);
            assert(advent1Code === '1010',
                `[${year}] CN I M√πa V·ªçng (${formatDate(litData.adventStart)}): code="${advent1Code}" - expected "1010"`);
            
            // Th·ª© Hai tu·∫ßn I M√πa V·ªçng
            const advent1Monday = new Date(litData.adventStart);
            advent1Monday.setDate(advent1Monday.getDate() + 1);
            const advent1MonCode = getLiturgicalDayCode(advent1Monday, litData);
            assert(advent1MonCode === '1011',
                `[${year}] Th·ª© Hai tu·∫ßn I M√πa V·ªçng (${formatDate(advent1Monday)}): code="${advent1MonCode}" - expected "1011"`);
            
            // Test 6: M√πa Gi√°ng Sinh (2DDMM)
            // 17/12 - 24/12: Tu·∫ßn chu·∫©n b·ªã Gi√°ng Sinh (ng√†y th∆∞·ªùng d√πng 2DDMM, Ch√∫a Nh·∫≠t d√πng 10TD)
            const dec17 = new Date(year, 11, 17);
            const dec17Code = getLiturgicalDayCode(dec17, litData);
            if (dec17.getDay() !== 0) {
                assert(dec17Code === '21712',
                    `[${year}] 17/12 (${formatDate(dec17)}): code="${dec17Code}" - expected "21712"`);
            } else {
                assert(dec17Code.startsWith('10'),
                    `[${year}] 17/12 (${formatDate(dec17)}): Ch√∫a Nh·∫≠t M√πa V·ªçng, code="${dec17Code}" - expected b·∫Øt ƒë·∫ßu "10"`);
            }
            
            // 25/12: L·ªÖ Gi√°ng Sinh
            const christmasCode = getLiturgicalDayCode(litData.christmas, litData);
            assert(christmasCode === '22512',
                `[${year}] 25/12 (${formatDate(litData.christmas)}): code="${christmasCode}" - expected "22512"`);
            
            // 01/01: ƒê·ª©c M·∫π l√† M·∫π Thi√™n Ch√∫a
            const jan1 = new Date(year, 0, 1);
            const jan1Code = getLiturgicalDayCode(jan1, litData);
            assert(jan1Code === '20101',
                `[${year}] 01/01 (${formatDate(jan1)}): code="${jan1Code}" - expected "20101"`);
            
            // Test 7: L·ªÖ Hi·ªÉn Linh (2030)
            const epiphanyCode = getLiturgicalDayCode(litData.epiphany, litData);
            assert(epiphanyCode === '2030',
                `[${year}] Hi·ªÉn Linh (${formatDate(litData.epiphany)}): code="${epiphanyCode}" - expected "2030"`);
            
            // Test 8: M√πa Chay (30TD, 306D)
            if (!litData.ashWednesdayTransferred) {
                // 3004: L·ªÖ Tro
                const ashCode = getLiturgicalDayCode(litData.ashWednesday, litData);
                assert(ashCode === '3004',
                    `[${year}] L·ªÖ Tro (${formatDate(litData.ashWednesday)}): code="${ashCode}" - expected "3004"`);
                
                // 3005-3007: Sau L·ªÖ Tro
                const ashThurs = new Date(litData.ashWednesday);
                ashThurs.setDate(ashThurs.getDate() + 1);
                const ashThursCode = getLiturgicalDayCode(ashThurs, litData);
                assert(ashThursCode === '3005',
                    `[${year}] Th·ª© NƒÉm sau L·ªÖ Tro (${formatDate(ashThurs)}): code="${ashThursCode}" - expected "3005"`);
            } else {
                // L·ªÖ Tro d·ªùi: m√£ 3004 ph·∫£i n·∫±m ·ªü ng√†y c·ª≠ h√†nh
                const ashCode = getLiturgicalDayCode(litData.ashWednesdayCelebration, litData);
                assert(ashCode === '3004',
                    `[${year}] L·ªÖ Tro (d·ªùi) (${formatDate(litData.ashWednesdayCelebration)}): code="${ashCode}" - expected "3004"`);
                
                // Ng√†y sau L·ªÖ Tro (d·ªùi) - n·∫øu kh√¥ng tr√πng T·∫øt th√¨ ph·∫£i l√† 3005
                const ashThurs = new Date(litData.ashWednesdayCelebration);
                ashThurs.setDate(ashThurs.getDate() + 1);
                const ashThursCode = getLiturgicalDayCode(ashThurs, litData);
                const tetDay = typeof LUNAR_CALENDAR !== 'undefined' ? LUNAR_CALENDAR.isTetDay(ashThurs) : 0;
                if (tetDay === 0) {
                    assert(ashThursCode === '3005',
                        `[${year}] Th·ª© NƒÉm sau L·ªÖ Tro (d·ªùi) (${formatDate(ashThurs)}): code="${ashThursCode}" - expected "3005"`);
                } else {
                    assert(ashThursCode === `7000${tetDay}`,
                        `[${year}] Th·ª© NƒÉm sau L·ªÖ Tro (d·ªùi) (${formatDate(ashThurs)}): tr√πng T·∫øt ‚Üí code="${ashThursCode}" - expected "7000${tetDay}"`);
                }
            }
            
            // Tu·∫ßn Th√°nh: 3060-3066
            // 3060: L·ªÖ L√° (CN)
            const palmCode = getLiturgicalDayCode(litData.palmSunday, litData);
            assert(palmCode === '3060',
                `[${year}] L·ªÖ L√° (${formatDate(litData.palmSunday)}): code="${palmCode}" - expected "3060"`);
            
            // 3065: Th·ª© S√°u Tu·∫ßn Th√°nh
            const goodFridayCode = getLiturgicalDayCode(litData.goodFriday, litData);
            assert(goodFridayCode === '3065',
                `[${year}] Th·ª© S√°u Tu·∫ßn Th√°nh (${formatDate(litData.goodFriday)}): code="${goodFridayCode}" - expected "3065"`);
            
            // Test 9: M√πa Ph·ª•c Sinh (40TD)
            // 4010: Ch√∫a Nh·∫≠t Ph·ª•c Sinh
            const easterCode = getLiturgicalDayCode(litData.easter, litData);
            assert(easterCode === '4010',
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}): code="${easterCode}" - expected "4010"`);
            
            // 4011: Th·ª© Hai tu·∫ßn B√°t Nh·∫≠t PS
            const easterMonday = new Date(litData.easter);
            easterMonday.setDate(easterMonday.getDate() + 1);
            const easterMonCode = getLiturgicalDayCode(easterMonday, litData);
            assert(easterMonCode === '4011',
                `[${year}] Th·ª© Hai tu·∫ßn B√°t Nh·∫≠t PS (${formatDate(easterMonday)}): code="${easterMonCode}" - expected "4011"`);
            
            // 4020: CN II Ph·ª•c Sinh (L√≤ng Ch√∫a Th∆∞∆°ng X√≥t)
            const easter2Sunday = new Date(litData.easter);
            easter2Sunday.setDate(easter2Sunday.getDate() + 7);
            const easter2Code = getLiturgicalDayCode(easter2Sunday, litData);
            assert(easter2Code === '4020',
                `[${year}] CN II Ph·ª•c Sinh (${formatDate(easter2Sunday)}): code="${easter2Code}" - expected "4020"`);
            
            // Test 10: ThƒÉng Thi√™n (4080)
            const ascensionCode = getLiturgicalDayCode(litData.ascension, litData);
            assert(ascensionCode === '4080',
                `[${year}] ThƒÉng Thi√™n (${formatDate(litData.ascension)}): code="${ascensionCode}" - expected "4080"`);
            
            // Test 11: V·ªçng Hi·ªán Xu·ªëng (4089)
            const pentecostVigil = new Date(litData.pentecost);
            pentecostVigil.setDate(pentecostVigil.getDate() - 1);
            const vigilCode = getLiturgicalDayCode(pentecostVigil, litData);
            assert(vigilCode === '4089',
                `[${year}] V·ªçng Hi·ªán Xu·ªëng (${formatDate(pentecostVigil)}): code="${vigilCode}" - expected "4089"`);
            
            // Test 12: Sanctoral (7DDMM) - Ki·ªÉm tra m·ªôt s·ªë l·ªÖ th√°nh c·ªë ƒë·ªãnh
            // 15/08: ƒê·ª©c M·∫π L√™n Tr·ªùi
            const aug15 = new Date(year, 7, 15);
            const aug15Code = getLiturgicalDayCode(aug15, litData);
            assert(aug15Code === '71508',
                `[${year}] 15/08 - ƒê·ª©c M·∫π L√™n Tr·ªùi (${formatDate(aug15)}): code="${aug15Code}" - expected "71508"`);
            
            // 24/11: C√°c Th√°nh T·ª≠ ƒê·∫°o VN
            const nov24 = new Date(year, 10, 24);
            const nov24Code = getLiturgicalDayCode(nov24, litData);
            assert(nov24Code === '72411',
                `[${year}] 24/11 - C√°c Th√°nh T·ª≠ ƒê·∫°o VN (${formatDate(nov24)}): code="${nov24Code}" - expected "72411"`);
            
            // Test 13: T·∫øt (7000D) - n·∫øu c√≥
            if (typeof LUNAR_CALENDAR !== 'undefined') {
                let tetDate = null;
                for (let month = 0; month <= 1; month++) {
                    for (let day = 1; day <= 31; day++) {
                        try {
                            const date = new Date(year, month, day);
                            if (date.getMonth() !== month) continue;
                            
                            const tetDay = LUNAR_CALENDAR.isTetDay(date);
                            if (tetDay === 1) {
                                tetDate = date;
                                break;
                            }
                        } catch (e) {}
                    }
                    if (tetDate) break;
                }
                
                if (tetDate) {
                    const tetCode = getLiturgicalDayCode(tetDate, litData);
                    assert(tetCode === '70001',
                        `[${year}] M√πng 1 T·∫øt (${formatDate(tetDate)}): code="${tetCode}" - expected "70001"`);
                    
                    // M√πng 2 T·∫øt
                    const tet2 = new Date(tetDate);
                    tet2.setDate(tet2.getDate() + 1);
                    const tet2Day = LUNAR_CALENDAR.isTetDay(tet2);
                    if (tet2Day === 2) {
                        const tet2Code = getLiturgicalDayCode(tet2, litData);
                        assert(tet2Code === '70002',
                            `[${year}] M√πng 2 T·∫øt (${formatDate(tet2)}): code="${tet2Code}" - expected "70002"`);
                    }
                }
            }
            
            // Test 14: Ki·ªÉm tra format m√£ - M√πa Th∆∞·ªùng Ni√™n ph·∫£i c√≥ format 5TTD
            const testOTDate = new Date(litData.baptismLord);
            testOTDate.setDate(testOTDate.getDate() + 14); // Tu·∫ßn 3
            const testOTCode = getLiturgicalDayCode(testOTDate, litData);
            if (testOTCode && testOTCode.startsWith('5') && testOTCode.length === 4) {
                const week = parseInt(testOTCode.substring(1, 3));
                const day = parseInt(testOTCode.substring(3));
                assert(week >= 1 && week <= 34 && day >= 0 && day <= 6,
                    `[${year}] Format m√£ TN (${testOTCode}): tu·∫ßn=${week}, th·ª©=${day} - h·ª£p l·ªá`);
            }
            
            // Test 15: Ki·ªÉm tra format m√£ - M√πa V·ªçng ph·∫£i c√≥ format 10TD
            const testAdventDate = new Date(litData.adventStart);
            testAdventDate.setDate(testAdventDate.getDate() + 7); // Tu·∫ßn 2
            const testAdventCode = getLiturgicalDayCode(testAdventDate, litData);
            if (testAdventCode && testAdventCode.startsWith('10')) {
                const week = parseInt(testAdventCode.substring(2, 3));
                const day = parseInt(testAdventCode.substring(3));
                assert(week >= 1 && week <= 4 && day >= 0 && day <= 6,
                    `[${year}] Format m√£ M√πa V·ªçng (${testAdventCode}): tu·∫ßn=${week}, th·ª©=${day} - h·ª£p l·ªá`);
            }
        }
        
        // ============================================================
        // F. TEST: Quy Lu·∫≠t Ph·ª•ng V·ª• (Strict)
        // ============================================================
        
        function testStrictLiturgicalRules(year) {
            log(`‚ïê‚ïê‚ïê ‚öñÔ∏è QUY LU·∫¨T PH·ª§NG V·ª§ (STRICT) - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            const litData = getLiturgicalData(year);
            
            // F1. 17-24/12 (ng√†y th∆∞·ªùng) ph·∫£i l√† M√πa V·ªçng, m√£ 2DDMM, m√†u t√≠m
            let adventWeekday = null;
            for (let d = 17; d <= 24; d++) {
                const date = new Date(year, 11, d);
                if (date.getDay() !== 0) {
                    adventWeekday = date;
                    break;
                }
            }
            if (adventWeekday) {
                const info = getDayInfo(adventWeekday, litData);
                const code = getLiturgicalDayCode(adventWeekday, litData);
                const dd = String(adventWeekday.getDate()).padStart(2, '0');
                const mm = String(adventWeekday.getMonth() + 1).padStart(2, '0');
                assert(info.season === 'M√πa V·ªçng',
                    `[${year}] 17-24/12 ng√†y th∆∞·ªùng (${formatDate(adventWeekday)}): season = M√πa V·ªçng ‚Üí ${info.season}`);
                assert(info.color === 'bg-lit-purple',
                    `[${year}] 17-24/12 ng√†y th∆∞·ªùng (${formatDate(adventWeekday)}): color = PURPLE ‚Üí ${info.color}`);
                assert(code === `2${dd}${mm}`,
                    `[${year}] 17-24/12 ng√†y th∆∞·ªùng (${formatDate(adventWeekday)}): code="${code}" - expected "2${dd}${mm}"`);
            } else {
                assert(false, `[${year}] 17-24/12: Kh√¥ng t√¨m th·∫•y ng√†y th∆∞·ªùng ƒë·ªÉ test`, true);
            }
            
            // F2. B√°t nh·∫≠t Gi√°ng Sinh: 31/12 (Sylvestro) kh√¥ng ƒë∆∞·ª£c l√†m ƒë·ªïi m√†u / kh√¥ng c·ª≠ h√†nh l·ªÖ nh·ªõ
            const dec31 = new Date(year, 11, 31);
            const dec31Info = getDayInfo(dec31, litData);
            const hasSylvestro = dec31Info.saints?.some(s => s.name && s.name.toLowerCase().includes('sylvestro'));
            if (typeof FIXED_DATA_LOOKUP !== 'undefined' && FIXED_DATA_LOOKUP['12-31']) {
                assert(!hasSylvestro && dec31Info.rankCode !== 'NHOKB',
                    `[${year}] 31/12 trong B√°t nh·∫≠t Gi√°ng Sinh: l·ªÖ nh·ªõ Sylvestro b·ªã suppress`);
            } else {
                assert(false, `[${year}] 31/12: Kh√¥ng t√¨m th·∫•y Sylvestro trong FIXED_DATA_LOOKUP`, true);
            }
            
            // F3. 26/12 (Th√°nh St√™phan√¥) l√† L·ªÖ K√≠nh n·∫øu kh√¥ng tr√πng Ch√∫a Nh·∫≠t
            const dec26 = new Date(year, 11, 26);
            if (dec26.getDay() !== 0) {
                const dec26Info = getDayInfo(dec26, litData);
                const hasStephen = dec26Info.saints?.some(s => s.name && s.name.toUpperCase().includes('ST√äPHAN√î')) ||
                                  (dec26Info.special && dec26Info.special.toUpperCase().includes('ST√äPHAN√î'));
                assert(hasStephen,
                    `[${year}] 26/12 (${formatDate(dec26)}): c√≥ Th√°nh St√™phan√¥`);
                assert(dec26Info.rankCode === 'KINH' || dec26Info.saints?.some(s => s.rank === 'KINH'),
                    `[${year}] 26/12 (${formatDate(dec26)}): rank = KINH`);
            } else {
                assert(false, `[${year}] 26/12 r∆°i v√†o Ch√∫a Nh·∫≠t: b·ªè qua test Th√°nh St√™phan√¥`, true);
            }
            
            // F4. L·ªÖ tr·ªçng c√≥ b√†i ƒë·ªçc ri√™ng (St Joseph, Truy·ªÅn Tin, V√¥ Nhi·ªÖm) ph·∫£i √©p sanctoral & c√≥ to√†n vƒÉn
            const forcedFeasts = [
                { label: 'Th√°nh Giuse', date: litData.stJoseph, key: '71903' },
                { label: 'L·ªÖ Truy·ªÅn Tin', date: litData.annunciation, key: '72503' },
                { label: 'ƒê·ª©c M·∫π V√¥ Nhi·ªÖm', date: litData.immConception, key: '70812' }
            ];
            
            forcedFeasts.forEach(f => {
                const info = getDayInfo(f.date, litData);
                const dayInfo = getDayLiturgicalInfo(f.date, litData);
                
                assert(info._forceSanctoralReadings === true,
                    `[${year}] ${f.label} (${formatDate(f.date)}): _forceSanctoralReadings = true`);
                assert(dayInfo.sanctoralCode === f.key,
                    `[${year}] ${f.label} (${formatDate(f.date)}): sanctoralCode="${dayInfo.sanctoralCode}" - expected "${f.key}"`);
                
                const full = getFullReadings(
                    dayInfo.dayCode,
                    dayInfo.sanctoralCode,
                    dayInfo.specialCode,
                    f.date.getDay(),
                    dayInfo.cycle,
                    dayInfo.weekdayCycle,
                    dayInfo.tetCode,
                    null
                );
                const san = full && full.length > 0 ? full.find(r => r.type === 'sanctoral') : null;
                const hasFullText = san && (
                    san.data?.firstReading?.content ||
                    san.data?.gospel?.content ||
                    (san.data?.psalms?.verses && san.data.psalms.verses.length > 0)
                );
                assert(Boolean(hasFullText),
                    `[${year}] ${f.label} (${formatDate(f.date)}): c√≥ b·∫£n vƒÉn ƒë·∫ßy ƒë·ªß trong sanctoral`);
            });
            
            // F5. D·ªØ li·ªáu b√†i ƒë·ªçc Gi√°ng Sinh ph·∫£i c√≥ ƒë·ªß kh√≥a ƒë·∫∑c bi·ªát
            if (typeof READINGS_SPECIAL !== 'undefined') {
                assert(Boolean(READINGS_SPECIAL['224122']),
                    `[${year}] L·ªÖ V·ªçng Gi√°ng Sinh (ban chi·ªÅu) c√≥ d·ªØ li·ªáu (224122)`);
                assert(Boolean(READINGS_SPECIAL['22512D']),
                    `[${year}] L·ªÖ Gi√°ng Sinh - L·ªÖ ƒê√™m c√≥ d·ªØ li·ªáu (22512D)`);
                assert(Boolean(READINGS_SPECIAL['22512']),
                    `[${year}] L·ªÖ Gi√°ng Sinh - L·ªÖ R·∫°ng ƒê√¥ng c√≥ d·ªØ li·ªáu (22512)`);
                assert(Boolean(READINGS_SPECIAL['22512R']),
                    `[${year}] L·ªÖ Gi√°ng Sinh - L·ªÖ Ban Ng√†y c√≥ d·ªØ li·ªáu (22512R)`);
            } else {
                assert(false, `[${year}] READINGS_SPECIAL ch∆∞a ƒë∆∞·ª£c load`, true);
            }
            
            // F6. Ch√∫a Nh·∫≠t cu·ªëi th√°ng 1 kh√¥ng ƒë∆∞·ª£c d√πng m√£ sanctoral (tr√°nh "Tu·∫ßn XXV")
            const jan25 = new Date(year, 0, 25);
            if (jan25.getDay() === 0) {
                const code = getLiturgicalDayCode(jan25, litData);
                assert(code.startsWith('5'),
                    `[${year}] CN 25/01 (${formatDate(jan25)}): code="${code}" ph·∫£i l√† M√πa Th∆∞·ªùng Ni√™n (5xx)`);
                
                const baptismSun = new Date(litData.baptismLord);
                baptismSun.setDate(baptismSun.getDate() - baptismSun.getDay());
                const janSun = new Date(jan25);
                janSun.setDate(janSun.getDate() - janSun.getDay());
                const expectedWeek = Math.floor((janSun - baptismSun) / (7 * 24 * 60 * 60 * 1000)) + 1;
                const week = parseInt(code.substring(1, 3), 10);
                assert(week === expectedWeek,
                    `[${year}] CN 25/01 (${formatDate(jan25)}): tu·∫ßn=${week} - expected ${expectedWeek}`);
            } else {
                assert(false, `[${year}] 25/01 kh√¥ng ph·∫£i Ch√∫a Nh·∫≠t: b·ªè qua test CN cu·ªëi th√°ng 1`, true);
            }
        }
        
        // ============================================================
        // MAIN TEST RUNNERS
        // ============================================================
        
        async function runStandardTests() {
            clearLog();
            log('üèÅ CH·∫†Y B·ªò TI√äU CHU·∫®N KI·ªÇM TH·ª¨ (A-E)', 'section');
            log('', 'info');
            
            // A. Date & ISO-Key
            testDateAndISOKey();
            updateStats();
            await new Promise(r => setTimeout(r, 50));
            
            // B-E cho nƒÉm hi·ªán t·∫°i v√† m·ªôt s·ªë nƒÉm m·∫´u
            const testYears = [2024, 2025, 2026, 2030, 2050];
            
            for (const year of testYears) {
                document.getElementById('testProgress').textContent = `ƒêang test nƒÉm ${year}...`;
                
                // B. Schema Validation
                testSchemaValidation(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // C. Liturgical Business
                testLiturgicalBusiness(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // D. Month Grid
                testMonthGrid(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // E. Regression
                testRegressionImportantDates(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // F. Strict Liturgical Rules
                testStrictLiturgicalRules(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
            }
            
            log('', 'info');
            log(`‚ú® HO√ÄN TH√ÄNH! Total: ${stats.total}, Passed: ${stats.passed}, Failed: ${stats.failed}, Warnings: ${stats.warnings}`, 'info');
            document.getElementById('testProgress').textContent = 'Ho√†n th√†nh!';
            
            const successRate = ((stats.passed / stats.total) * 100).toFixed(2);
            log(`üìä T·ª∑ l·ªá th√†nh c√¥ng: ${successRate}%`, successRate >= 95 ? 'pass' : 'warn');
        }
        
        async function runTests() {
            clearLog();
            
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);
            const testType = document.getElementById('testType').value;
            
            log(`üöÄ B·∫Øt ƒë·∫ßu test t·ª´ nƒÉm ${startYear} ƒë·∫øn ${endYear}...`, 'info');
            log(`Lo·∫°i test: ${testType}`, 'info');
            log('', 'info');
            
            // Run standard tests first if selected
            if (testType === 'standards' || testType === 'dateISO') {
                testDateAndISOKey();
                updateStats();
            }
            
            const totalYears = endYear - startYear + 1;
            
            for (let year = startYear; year <= endYear; year++) {
                document.getElementById('testProgress').textContent = 
                    `ƒêang test: ${year} (${year - startYear + 1}/${totalYears})`;
                
                try {
                    if (testType === 'all' || testType === 'standards' || testType === 'schema') {
                        testSchemaValidation(year);
                    }
                    if (testType === 'all' || testType === 'standards' || testType === 'business') {
                        testLiturgicalBusiness(year);
                    }
                    if (testType === 'all' || testType === 'standards' || testType === 'monthGrid') {
                        testMonthGrid(year);
                    }
                    if (testType === 'all' || testType === 'standards' || testType === 'regression') {
                        testRegressionImportantDates(year);
                    }
                    if (testType === 'all' || testType === 'easter') {
                        testEaster(year);
                    }
                    if (testType === 'all' || testType === 'epiphany') {
                        testEpiphanyAndBaptism(year);
                    }
                    if (testType === 'all' || testType === 'lent') {
                        testLent(year);
                    }
                    if (testType === 'all' || testType === 'advent') {
                        testAdvent(year);
                    }
                    if (testType === 'all' || testType === 'tet') {
                        testTet(year);
                    }
                    if (testType === 'all' || testType === 'readingCode') {
                        testReadingCodeRules(year);
                    }
                    if (testType === 'all' || testType === 'validateCodeFormat') {
                        if (year === startYear) {
                            // Ch·∫°y test cho readingdata.js (ch·ªâ 1 l·∫ßn)
                            testReadingDataCodeFormat();
                        }
                        // Ch·∫°y test cho controller.js (m·ªói nƒÉm)
                        testControllerCodeFormat(year);
                    }
                    if (testType === 'all' || testType === 'strictRules') {
                        testStrictLiturgicalRules(year);
                    }
                } catch (e) {
                    log(`[${year}] ‚ùå ERROR: ${e.message}`, 'fail');
                    stats.failed++;
                    console.error(e);
                }
                
                updateStats();
                
                if (year % 10 === 0) {
                    await new Promise(r => setTimeout(r, 10));
                }
            }
            
            log('', 'info');
            log(`‚ú® Ho√†n th√†nh! Total: ${stats.total}, Passed: ${stats.passed}, Failed: ${stats.failed}, Warnings: ${stats.warnings}`, 'info');
            document.getElementById('testProgress').textContent = 'Ho√†n th√†nh!';
            
            const successRate = ((stats.passed / stats.total) * 100).toFixed(2);
            log(`üìä T·ª∑ l·ªá th√†nh c√¥ng: ${successRate}%`, successRate >= 95 ? 'pass' : 'warn');
        }
        
        // Quick test on load
        window.onload = function() {
            log('üîÑ S·∫µn s√†ng test. Ch·ªçn lo·∫°i test v√† nh·∫•n "Ch·∫°y Test".', 'info');
            log('üí° Nh·∫•n "Ch·∫°y Ti√™u Chu·∫©n" ƒë·ªÉ test b·ªô ti√™u chu·∫©n A-E v·ªõi c√°c nƒÉm m·∫´u.', 'info');
            log('', 'info');
            log('üìã B·ªò TI√äU CHU·∫®N KI·ªÇM TH·ª¨:', 'section');
            log('  A. Date & ISO-key (Timezone Safety)', 'info');
            log('  B. Schema Validation (Data Integrity)', 'info');
            log('  C. Nghi·ªáp v·ª• Ph·ª•ng v·ª• C∆° b·∫£n', 'info');
            log('  D. Month Grid Correctness', 'info');
            log('  E. Regression - Ng√†y Quan Tr·ªçng', 'info');
            log('  F. Quy Lu·∫≠t Ph·ª•ng V·ª• (Strict)', 'info');
        };
    </script>
</body>
</html>
