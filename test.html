<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test L·ªãch Ph·ª•ng V·ª• - B·ªô Ti√™u Chu·∫©n Ki·ªÉm Th·ª≠</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .test-pass { background-color: #dcfce7; color: #166534; }
        .test-fail { background-color: #fee2e2; color: #991b1b; }
        .test-warn { background-color: #fef3c7; color: #92400e; }
        .test-section { background-color: #e0f2fe; color: #0369a1; font-weight: bold; }
        .test-info { background-color: #f9fafb; }
        .log-entry { font-family: monospace; font-size: 0.85rem; padding: 4px 8px; border-bottom: 1px solid #e5e7eb; }
        .log-entry.hidden { display: none; }
        #testLog { max-height: 600px; overflow-y: auto; }
        
        /* Filter button styles */
        .filter-btn { cursor: pointer; }
        .filter-btn.active { border-color: #3b82f6 !important; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
        #btnAll.active { border-color: #6b7280 !important; box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.3); }
        #btnPass.active { border-color: #16a34a !important; box-shadow: 0 0 0 2px rgba(22, 163, 74, 0.3); }
        #btnFail.active { border-color: #dc2626 !important; box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.3); }
        #btnWarn.active { border-color: #d97706 !important; box-shadow: 0 0 0 2px rgba(217, 119, 6, 0.3); }
    </style>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-2">üß™ Test L·ªãch Ph·ª•ng V·ª•</h1>
        <p class="text-center text-gray-500 mb-8">B·ªô Ti√™u Chu·∫©n Ki·ªÉm Th·ª≠ To√†n Di·ªán</p>
        
        <!-- Controls -->
        <div class="bg-white p-6 rounded-xl shadow-md mb-6">
            <div class="flex flex-wrap gap-4 items-end">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">NƒÉm b·∫Øt ƒë·∫ßu</label>
                    <input type="number" id="startYear" value="2000" class="border rounded px-3 py-2 w-24">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">NƒÉm k·∫øt th√∫c</label>
                    <input type="number" id="endYear" value="2100" class="border rounded px-3 py-2 w-24">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Lo·∫°i test</label>
                    <select id="testType" class="border rounded px-3 py-2">
                        <option value="all">üîÑ T·∫•t c·∫£</option>
                        <option value="standards">üìã Ti√™u chu·∫©n (A-E)</option>
                        <option value="dateISO">üìÖ A. Date & ISO-key</option>
                        <option value="schema">üìù B. Schema Validation</option>
                        <option value="business">‚õ™ C. Nghi·ªáp v·ª• Ph·ª•ng v·ª•</option>
                        <option value="monthGrid">üìÜ D. Month Grid</option>
                        <option value="regression">üîÅ E. Regression</option>
                        <option value="easter">üê£ Easter/Ph·ª•c Sinh</option>
                        <option value="epiphany">‚≠ê Hi·ªÉn Linh & Ph√©p R·ª≠a</option>
                        <option value="lent">‚úùÔ∏è M√πa Chay</option>
                        <option value="advent">üïØÔ∏è M√πa V·ªçng</option>
                        <option value="tet">üéä T·∫øt Nguy√™n ƒê√°n</option>
                    </select>
                </div>
                <button onclick="runTests()" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 font-semibold">
                    ‚ñ∂ Ch·∫°y Test
                </button>
                <button onclick="runStandardTests()" class="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700 font-semibold">
                    üìã Ch·∫°y Ti√™u Chu·∫©n
                </button>
                <button onclick="clearLog()" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                    X√≥a Log
                </button>
            </div>
        </div>
        
        <!-- Summary - Filter Buttons -->
        <div class="grid grid-cols-4 gap-4 mb-6">
            <button onclick="filterLog('all')" id="btnAll" title="Hi·ªÉn th·ªã t·∫•t c·∫£" class="filter-btn active bg-white p-4 rounded-xl shadow-md text-center hover:bg-gray-50 transition-all border-2 border-transparent focus:outline-none">
                <div id="totalTests" class="text-3xl font-bold text-gray-800">0</div>
                <div class="text-sm text-gray-500">T·ªïng Tests</div>
                <div class="text-xs text-gray-400 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
            <button onclick="filterLog('pass')" id="btnPass" title="Ch·ªâ hi·ªÉn th·ªã passed" class="filter-btn bg-green-50 p-4 rounded-xl shadow-md text-center hover:bg-green-100 transition-all border-2 border-transparent focus:outline-none">
                <div id="passedTests" class="text-3xl font-bold text-green-600">0</div>
                <div class="text-sm text-green-700">Passed</div>
                <div class="text-xs text-green-500 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
            <button onclick="filterLog('fail')" id="btnFail" title="Ch·ªâ hi·ªÉn th·ªã failed" class="filter-btn bg-red-50 p-4 rounded-xl shadow-md text-center hover:bg-red-100 transition-all border-2 border-transparent focus:outline-none">
                <div id="failedTests" class="text-3xl font-bold text-red-600">0</div>
                <div class="text-sm text-red-700">Failed</div>
                <div class="text-xs text-red-400 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
            <button onclick="filterLog('warn')" id="btnWarn" title="Ch·ªâ hi·ªÉn th·ªã warnings" class="filter-btn bg-yellow-50 p-4 rounded-xl shadow-md text-center hover:bg-yellow-100 transition-all border-2 border-transparent focus:outline-none">
                <div id="warnTests" class="text-3xl font-bold text-yellow-600">0</div>
                <div class="text-sm text-yellow-700">Warnings</div>
                <div class="text-xs text-yellow-500 mt-1">Click ƒë·ªÉ l·ªçc</div>
            </button>
        </div>
        
        <!-- Test Log -->
        <div class="bg-white rounded-xl shadow-md overflow-hidden">
            <div class="bg-gray-800 text-white px-4 py-2 font-semibold flex justify-between items-center">
                <span>üìã Test Log</span>
                <span id="testProgress" class="text-sm text-gray-300"></span>
            </div>
            <div id="testLog" class="bg-gray-50"></div>
        </div>
        
        <!-- Detailed Year View -->
        <div id="detailView" class="mt-6 hidden">
            <div class="bg-white rounded-xl shadow-md p-6">
                <h2 class="text-xl font-bold mb-4">üìÖ Chi ti·∫øt nƒÉm <span id="detailYear"></span></h2>
                <div id="detailContent" class="grid grid-cols-2 gap-4"></div>
            </div>
        </div>
    </div>

    <!-- Load all reading data files -->
    <script src="Reading/readingdata.js"></script>
    <script src="Reading/readings_year_1.js"></script>
    <script src="Reading/readings_year_2.js"></script>
    <script src="Reading/Sunday.js"></script>
    <script src="Reading/DailySeason.js"></script>
    <script src="Reading/Saints.js"></script>
    <script src="Reading/SaintsBible.js"></script>
    <script src="Reading/Optionsaint.js"></script>
    <script src="Reading/eucharisticAdoration.js"></script>
    <script src="js/controller.js"></script>
    
    <script>
        // ============================================================
        // TEST UTILITIES & STATISTICS
        // ============================================================
        
        let stats = { total: 0, passed: 0, failed: 0, warnings: 0 };
        
        // Enum definitions for validation
        const VALID_RANKS = ['TRONG', 'KINH', 'NHO', 'NHOKB', 'CHUA_NHAT', 'NGAY_THUONG', 'O'];
        const VALID_COLORS = ['bg-lit-green', 'bg-lit-purple', 'bg-lit-white', 'bg-lit-red', 'bg-lit-rose'];
        const VALID_SEASONS = ['M√πa Th∆∞·ªùng Ni√™n', 'M√πa V·ªçng', 'M√πa Gi√°ng Sinh', 'M√πa Chay', 'M√πa Ph·ª•c Sinh', 'Tam Nh·∫≠t V∆∞·ª£t Qua'];
        
        // ============================================================
        // A. DATE & ISO-KEY UTILITIES (Timezone Safety)
        // ============================================================
        
        // Chu·∫©n: toISODate lu√¥n tr·∫£ YYYY-MM-DD ƒë√∫ng theo ng√†y ƒë·ªãa ph∆∞∆°ng
        function toISODate(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Chu·∫©n: Parse date-string kh√¥ng d√πng new Date("YYYY-MM-DD") v√¨ c√≥ th·ªÉ b·ªã hi·ªÉu nh∆∞ UTC
        function parseDateString(dateStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            return new Date(year, month - 1, day);
        }
        
        // Helper functions
        function formatDate(date) {
            if (!date) return 'N/A';
            const d = new Date(date);
            return `${d.getDate().toString().padStart(2, '0')}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getFullYear()}`;
        }
        
        function getDayName(date) {
            const days = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];
            return days[new Date(date).getDay()];
        }
        
        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        }
        
        function daysInMonth(year, month) {
            return new Date(year, month + 1, 0).getDate();
        }
        
        // Current filter state
        let currentFilter = 'all';
        
        // Logging
        function log(message, type = 'info') {
            const logEl = document.getElementById('testLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.setAttribute('data-type', type);
            
            if (type === 'pass') entry.classList.add('test-pass');
            else if (type === 'fail') entry.classList.add('test-fail');
            else if (type === 'warn') entry.classList.add('test-warn');
            else if (type === 'section') entry.classList.add('test-section');
            else entry.classList.add('test-info');
            
            // Apply current filter
            if (currentFilter !== 'all' && currentFilter !== type) {
                entry.classList.add('hidden');
            }
            
            const icons = { pass: '‚úÖ', fail: '‚ùå', warn: '‚ö†Ô∏è', info: '‚ÑπÔ∏è', section: 'üìå' };
            entry.innerHTML = `${icons[type] || '‚ÑπÔ∏è'} ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        // Filter log entries
        function filterLog(filterType) {
            currentFilter = filterType;
            const entries = document.querySelectorAll('#testLog .log-entry');
            
            entries.forEach(entry => {
                const entryType = entry.getAttribute('data-type');
                
                if (filterType === 'all') {
                    // Show all entries
                    entry.classList.remove('hidden');
                } else if (filterType === entryType) {
                    // Show matching entries
                    entry.classList.remove('hidden');
                } else if (entryType === 'section') {
                    // Always show section headers for context
                    entry.classList.remove('hidden');
                } else {
                    // Hide non-matching entries
                    entry.classList.add('hidden');
                }
            });
            
            // Update active button state
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = {
                'all': 'btnAll',
                'pass': 'btnPass',
                'fail': 'btnFail',
                'warn': 'btnWarn'
            };
            
            if (activeBtn[filterType]) {
                document.getElementById(activeBtn[filterType]).classList.add('active');
            }
            
            // Update filtered count display
            updateFilteredCount(filterType);
        }
        
        // Show filtered count in progress area
        function updateFilteredCount(filterType) {
            if (filterType === 'all') {
                document.getElementById('testProgress').textContent = 'Hi·ªÉn th·ªã t·∫•t c·∫£';
                return;
            }
            
            const totalCount = document.querySelectorAll(`#testLog .log-entry[data-type="${filterType}"]`).length;
            const labels = { pass: '‚úÖ Passed', fail: '‚ùå Failed', warn: '‚ö†Ô∏è Warnings' };
            document.getElementById('testProgress').textContent = `ƒêang l·ªçc: ${totalCount} ${labels[filterType] || filterType}`;
        }
        
        function updateStats() {
            document.getElementById('totalTests').textContent = stats.total;
            document.getElementById('passedTests').textContent = stats.passed;
            document.getElementById('failedTests').textContent = stats.failed;
            document.getElementById('warnTests').textContent = stats.warnings;
        }
        
        function clearLog() {
            document.getElementById('testLog').innerHTML = '';
            stats = { total: 0, passed: 0, failed: 0, warnings: 0 };
            updateStats();
            
            // Reset filter to 'all'
            currentFilter = 'all';
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btnAll').classList.add('active');
            document.getElementById('testProgress').textContent = '';
        }
        
        function assert(condition, message, warnOnly = false) {
            stats.total++;
            if (condition) {
                stats.passed++;
                log(message, 'pass');
                return true;
            } else {
                if (warnOnly) {
                    stats.warnings++;
                    log(message, 'warn');
                } else {
                    stats.failed++;
                    log(message, 'fail');
                }
                return false;
            }
        }
        
        // ============================================================
        // A. TEST: Date & ISO-Key (Timezone Safety)
        // ============================================================
        
        function testDateAndISOKey() {
            log('‚ïê‚ïê‚ïê A. DATE & ISO-KEY (Timezone Safety) ‚ïê‚ïê‚ïê', 'section');
            
            // Test 1: toISODate v·ªõi ng√†y cu·ªëi th√°ng
            const march31 = new Date(2024, 2, 31); // March 31, 2024
            assert(toISODate(march31) === "2024-03-31",
                `toISODate(new Date(2024,2,31)) === "2024-03-31" ‚Üí ${toISODate(march31)}`);
            
            // Test 2: toISODate v·ªõi ng√†y ƒë·∫ßu th√°ng
            const jan1 = new Date(2024, 0, 1);
            assert(toISODate(jan1) === "2024-01-01",
                `toISODate(new Date(2024,0,1)) === "2024-01-01" ‚Üí ${toISODate(jan1)}`);
            
            // Test 3: toISODate v·ªõi nƒÉm nhu·∫≠n 29/2
            const feb29 = new Date(2024, 1, 29);
            assert(toISODate(feb29) === "2024-02-29",
                `toISODate(new Date(2024,1,29)) === "2024-02-29" ‚Üí ${toISODate(feb29)}`);
            
            // Test 4: parseDateString round-trip
            const testDateStr = "2024-03-31";
            const parsed = parseDateString(testDateStr);
            const roundTrip = toISODate(parsed);
            assert(roundTrip === testDateStr,
                `parseDateString("2024-03-31") round-trip ‚Üí ${roundTrip}`);
            
            // Test 5: parseDateString kh√¥ng d√πng UTC
            const parsed2 = parseDateString("2024-12-31");
            assert(parsed2.getDate() === 31 && parsed2.getMonth() === 11,
                `parseDateString("2024-12-31").getDate() === 31, getMonth() === 11`);
            
            // Test 6: Consistency across different dates
            const testDates = [
                "2024-01-01", "2024-02-29", "2024-06-15", 
                "2024-12-31", "2025-03-01", "2100-02-28"
            ];
            let allPass = true;
            for (const dateStr of testDates) {
                const d = parseDateString(dateStr);
                if (toISODate(d) !== dateStr) {
                    allPass = false;
                    log(`Round-trip failed for ${dateStr} ‚Üí ${toISODate(d)}`, 'fail');
                    stats.failed++;
                }
            }
            if (allPass) {
                stats.total++;
                stats.passed++;
                log(`T·∫•t c·∫£ ${testDates.length} date strings round-trip th√†nh c√¥ng`, 'pass');
            }
        }
        
        // ============================================================
        // B. TEST: Schema Validation (Data Integrity)
        // ============================================================
        
        function testSchemaValidation(year) {
            log(`‚ïê‚ïê‚ïê B. SCHEMA VALIDATION - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            const litData = getLiturgicalData(year);
            const totalDays = isLeapYear(year) ? 366 : 365;
            let schemaErrors = 0;
            let sampleErrors = [];
            
            // Ki·ªÉm tra t·∫•t c·∫£ 365/366 ng√†y trong nƒÉm
            for (let month = 0; month < 12; month++) {
                const daysInM = daysInMonth(year, month);
                for (let day = 1; day <= daysInM; day++) {
                    const date = new Date(year, month, day);
                    const info = getDayInfo(date, litData);
                    
                    // Ki·ªÉm tra c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
                    const requiredFields = ['season', 'color', 'rankCode'];
                    for (const field of requiredFields) {
                        if (info[field] === undefined || info[field] === null) {
                            schemaErrors++;
                            if (sampleErrors.length < 5) {
                                sampleErrors.push(`${formatDate(date)}: thi·∫øu tr∆∞·ªùng "${field}"`);
                            }
                        }
                    }
                    
                    // Validate rank enum
                    if (info.rankCode && !VALID_RANKS.includes(info.rankCode)) {
                        schemaErrors++;
                        if (sampleErrors.length < 5) {
                            sampleErrors.push(`${formatDate(date)}: rankCode "${info.rankCode}" kh√¥ng h·ª£p l·ªá`);
                        }
                    }
                    
                    // Validate color enum
                    if (info.color && !VALID_COLORS.includes(info.color)) {
                        schemaErrors++;
                        if (sampleErrors.length < 5) {
                            sampleErrors.push(`${formatDate(date)}: color "${info.color}" kh√¥ng h·ª£p l·ªá`);
                        }
                    }
                    
                    // Validate season enum
                    if (info.season && !VALID_SEASONS.includes(info.season)) {
                        schemaErrors++;
                        if (sampleErrors.length < 5) {
                            sampleErrors.push(`${formatDate(date)}: season "${info.season}" kh√¥ng h·ª£p l·ªá`);
                        }
                    }
                }
            }
            
            if (schemaErrors === 0) {
                stats.total++;
                stats.passed++;
                log(`[${year}] T·∫•t c·∫£ ${totalDays} ng√†y ƒë·ªÅu ƒë·∫°t schema validation`, 'pass');
            } else {
                stats.total++;
                stats.failed++;
                log(`[${year}] Schema errors: ${schemaErrors}`, 'fail');
                sampleErrors.forEach(err => log(`  ‚Üí ${err}`, 'fail'));
            }
            
            // Test saints array lu√¥n l√† array
            const randomDate = new Date(year, 5, 15);
            const randomInfo = getDayInfo(randomDate, litData);
            assert(Array.isArray(randomInfo.saints),
                `[${year}] getDayInfo().saints l√† Array`);
            
            // Test commemorations lu√¥n l√† array  
            assert(Array.isArray(randomInfo.commemorations),
                `[${year}] getDayInfo().commemorations l√† Array`);
        }
        
        // ============================================================
        // C. TEST: Nghi·ªáp v·ª• Ph·ª•ng v·ª• C∆° b·∫£n
        // ============================================================
        
        function testLiturgicalBusiness(year) {
            log(`‚ïê‚ïê‚ïê C. NGHI·ªÜP V·ª§ PH·ª§NG V·ª§ C∆† B·∫¢N - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            const litData = getLiturgicalData(year);
            
            // C1. Ki·ªÉm tra ng√†y 1/1 - ƒê·ª©c M·∫π l√† M·∫π Thi√™n Ch√∫a
            const jan1 = new Date(year, 0, 1);
            const jan1Info = getDayInfo(jan1, litData);
            
            const jan1HasMary = jan1Info.special?.includes('MARIA') || 
                               jan1Info.special?.includes('M·∫π Thi√™n Ch√∫a') ||
                               jan1Info.saints?.some(s => s.name?.includes('MARIA'));
            assert(jan1HasMary,
                `[${year}] 01/01: ƒê·ª©c M·∫π l√† M·∫π Thi√™n Ch√∫a - special="${jan1Info.special}"`);
            
            assert(jan1Info.color === 'bg-lit-white',
                `[${year}] 01/01: color = WHITE ‚Üí ${jan1Info.color}`);
            
            // C2. Ki·ªÉm tra L·ªÖ Tro - Th·ª© T∆∞, m√†u t√≠m
            if (!litData.ashWednesdayTransferred) {
                const ashInfo = getDayInfo(litData.ashWednesday, litData);
                assert(ashInfo.special?.includes('Tro'),
                    `[${year}] L·ªÖ Tro (${formatDate(litData.ashWednesday)}): "${ashInfo.special}" ch·ª©a "Tro"`);
                assert(ashInfo.color === 'bg-lit-purple',
                    `[${year}] L·ªÖ Tro: color = PURPLE ‚Üí ${ashInfo.color}`);
                assert(ashInfo.season === 'M√πa Chay',
                    `[${year}] L·ªÖ Tro: season = M√πa Chay ‚Üí ${ashInfo.season}`);
            }
            
            // C3. Ki·ªÉm tra Ph·ª•c Sinh - m√†u tr·∫Øng
            const easterInfo = getDayInfo(litData.easter, litData);
            assert(easterInfo.special?.includes('Ph·ª•c Sinh'),
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}): "${easterInfo.special}" ch·ª©a "Ph·ª•c Sinh"`);
            assert(easterInfo.color === 'bg-lit-white',
                `[${year}] Ph·ª•c Sinh: color = WHITE ‚Üí ${easterInfo.color}`);
            assert(easterInfo.rankCode === 'TRONG',
                `[${year}] Ph·ª•c Sinh: rank = TRONG ‚Üí ${easterInfo.rankCode}`);
            
            // C4. Ki·ªÉm tra Th·ª© S√°u Tu·∫ßn Th√°nh - m√†u ƒë·ªè (kh√¥ng ph·∫£i t√≠m!)
            const goodFridayInfo = getDayInfo(litData.goodFriday, litData);
            assert(goodFridayInfo.color === 'bg-lit-red',
                `[${year}] Good Friday: color = RED (kh√¥ng ph·∫£i t√≠m!) ‚Üí ${goodFridayInfo.color}`);
            
            // C5. Ki·ªÉm tra Gi√°ng Sinh 25/12
            const christmas = new Date(year, 11, 25);
            const xmasInfo = getDayInfo(christmas, litData);
            assert(xmasInfo.season === 'M√πa Gi√°ng Sinh',
                `[${year}] 25/12: season = M√πa Gi√°ng Sinh ‚Üí ${xmasInfo.season}`);
            assert(xmasInfo.color === 'bg-lit-white',
                `[${year}] 25/12: color = WHITE ‚Üí ${xmasInfo.color}`);
            
            // C6. Ki·ªÉm tra M√πa V·ªçng - m√†u t√≠m
            const adventSundayInfo = getDayInfo(litData.adventStart, litData);
            assert(adventSundayInfo.color === 'bg-lit-purple',
                `[${year}] CN I M√πa V·ªçng: color = PURPLE ‚Üí ${adventSundayInfo.color}`);
            assert(adventSundayInfo.season === 'M√πa V·ªçng',
                `[${year}] CN I M√πa V·ªçng: season = M√πa V·ªçng ‚Üí ${adventSundayInfo.season}`);
        }
        
        // ============================================================
        // D. TEST: Month Grid Correctness
        // ============================================================
        
        function testMonthGrid(year) {
            log(`‚ïê‚ïê‚ïê D. MONTH GRID CORRECTNESS - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            // D1. Th√°ng 2 nƒÉm nhu·∫≠n ph·∫£i c√≥ 29 ng√†y
            if (isLeapYear(year)) {
                const feb = daysInMonth(year, 1);
                assert(feb === 29,
                    `[${year}] Th√°ng 2 (nƒÉm nhu·∫≠n) c√≥ ${feb} ng√†y - expected 29`);
            } else {
                const feb = daysInMonth(year, 1);
                assert(feb === 28,
                    `[${year}] Th√°ng 2 (kh√¥ng nhu·∫≠n) c√≥ ${feb} ng√†y - expected 28`);
            }
            
            // D2. Th√°ng 4 ph·∫£i c√≥ 30 ng√†y
            const apr = daysInMonth(year, 3);
            assert(apr === 30,
                `[${year}] Th√°ng 4 c√≥ ${apr} ng√†y - expected 30`);
            
            // D3. Th√°ng 1 ph·∫£i c√≥ 31 ng√†y
            const jan = daysInMonth(year, 0);
            assert(jan === 31,
                `[${year}] Th√°ng 1 c√≥ ${jan} ng√†y - expected 31`);
            
            // D4. Ki·ªÉm tra t·∫•t c·∫£ th√°ng c√≥ s·ªë ng√†y ƒë√∫ng
            const expectedDays = [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            let allCorrect = true;
            for (let m = 0; m < 12; m++) {
                const actual = daysInMonth(year, m);
                if (actual !== expectedDays[m]) {
                    allCorrect = false;
                    log(`[${year}] Th√°ng ${m+1} c√≥ ${actual} ng√†y, expected ${expectedDays[m]}`, 'fail');
                    stats.failed++;
                }
            }
            if (allCorrect) {
                stats.total++;
                stats.passed++;
                log(`[${year}] T·∫•t c·∫£ 12 th√°ng c√≥ s·ªë ng√†y ƒë√∫ng`, 'pass');
            }
            
            // D5. Ki·ªÉm tra ng√†y trong th√°ng ƒëi t·ª´ 1..lastDay
            const litData = getLiturgicalData(year);
            for (let m = 0; m < 12; m++) {
                const lastDay = daysInMonth(year, m);
                for (let d = 1; d <= lastDay; d++) {
                    const date = new Date(year, m, d);
                    if (date.getDate() !== d || date.getMonth() !== m) {
                        stats.total++;
                        stats.failed++;
                        log(`[${year}] Date overflow: ${year}-${m+1}-${d} ‚Üí ${formatDate(date)}`, 'fail');
                        return;
                    }
                }
            }
            stats.total++;
            stats.passed++;
            log(`[${year}] T·∫•t c·∫£ ng√†y trong nƒÉm validate ƒë√∫ng`, 'pass');
        }
        
        // ============================================================
        // E. TEST: Regression - Ng√†y Quan Tr·ªçng
        // ============================================================
        
        function testRegressionImportantDates(year) {
            log(`‚ïê‚ïê‚ïê E. REGRESSION - NG√ÄY QUAN TR·ªåNG - NƒÉm ${year} ‚ïê‚ïê‚ïê`, 'section');
            
            const litData = getLiturgicalData(year);
            
            // E1. Ph·ª•c Sinh ph·∫£i n·∫±m trong 22/3 - 25/4
            const easterMonth = litData.easter.getMonth();
            const easterDate = litData.easter.getDate();
            const validEaster = (easterMonth === 2 && easterDate >= 22) || 
                               (easterMonth === 3 && easterDate <= 25);
            assert(validEaster,
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}) ‚àà [22/3 - 25/4]`);
            
            // E2. Ph·ª•c Sinh ph·∫£i l√† Ch√∫a Nh·∫≠t
            assert(litData.easter.getDay() === 0,
                `[${year}] Ph·ª•c Sinh (${formatDate(litData.easter)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E3. L·ªÖ Tro = Ph·ª•c Sinh - 46 ng√†y
            const ashToEaster = Math.round((litData.easter - litData.ashWednesday) / (24*60*60*1000));
            assert(ashToEaster === 46,
                `[${year}] L·ªÖ Tro c√°ch Ph·ª•c Sinh ${ashToEaster} ng√†y - expected 46`);
            
            // E4. L·ªÖ Tro ph·∫£i l√† Th·ª© T∆∞
            assert(litData.ashWednesday.getDay() === 3,
                `[${year}] L·ªÖ Tro (${formatDate(litData.ashWednesday)}) l√† Th·ª© T∆∞`);
            
            // E5. CN I M√πa V·ªçng ‚àà [27/11 - 03/12]
            const adventMonth = litData.adventStart.getMonth();
            const adventDate = litData.adventStart.getDate();
            const validAdvent = (adventMonth === 10 && adventDate >= 27) || 
                               (adventMonth === 11 && adventDate <= 3);
            assert(validAdvent,
                `[${year}] CN I M√πa V·ªçng (${formatDate(litData.adventStart)}) ‚àà [27/11 - 03/12]`);
            
            // E6. CN I M√πa V·ªçng ph·∫£i l√† Ch√∫a Nh·∫≠t
            assert(litData.adventStart.getDay() === 0,
                `[${year}] CN I M√πa V·ªçng (${formatDate(litData.adventStart)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E7. ThƒÉng Thi√™n = Ph·ª•c Sinh + 39 ng√†y (Th·ª© NƒÉm truy·ªÅn th·ªëng VN)
            const ascensionDiff = Math.round((litData.ascension - litData.easter) / (24*60*60*1000));
            assert(ascensionDiff === 39,
                `[${year}] ThƒÉng Thi√™n c√°ch Ph·ª•c Sinh ${ascensionDiff} ng√†y - expected 39`);
            
            // E8. ThƒÉng Thi√™n ph·∫£i l√† Th·ª© NƒÉm
            assert(litData.ascension.getDay() === 4,
                `[${year}] ThƒÉng Thi√™n (${formatDate(litData.ascension)}) l√† Th·ª© NƒÉm`);
            
            // E9. Hi·ªán Xu·ªëng = Ph·ª•c Sinh + 49 ng√†y
            const pentecostDiff = Math.round((litData.pentecost - litData.easter) / (24*60*60*1000));
            assert(pentecostDiff === 49,
                `[${year}] Hi·ªán Xu·ªëng c√°ch Ph·ª•c Sinh ${pentecostDiff} ng√†y - expected 49`);
            
            // E10. Hi·ªán Xu·ªëng ph·∫£i l√† Ch√∫a Nh·∫≠t
            assert(litData.pentecost.getDay() === 0,
                `[${year}] Hi·ªán Xu·ªëng (${formatDate(litData.pentecost)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E11. Hi·ªÉn Linh ‚àà [02/01 - 08/01] v√† l√† Ch√∫a Nh·∫≠t
            const epiphanyMonth = litData.epiphany.getMonth();
            const epiphanyDate = litData.epiphany.getDate();
            const validEpiphany = epiphanyMonth === 0 && epiphanyDate >= 2 && epiphanyDate <= 8;
            assert(validEpiphany,
                `[${year}] Hi·ªÉn Linh (${formatDate(litData.epiphany)}) ‚àà [02/01 - 08/01]`);
            assert(litData.epiphany.getDay() === 0,
                `[${year}] Hi·ªÉn Linh (${formatDate(litData.epiphany)}) l√† Ch√∫a Nh·∫≠t`);
            
            // E12. Ch√∫a Kit√¥ Vua = CN I M√πa V·ªçng - 7 ng√†y
            const christKingDiff = Math.round((litData.adventStart - litData.christKing) / (24*60*60*1000));
            assert(christKingDiff === 7,
                `[${year}] Ch√∫a Kit√¥ Vua c√°ch CN I M√πa V·ªçng ${christKingDiff} ng√†y - expected 7`);
        }
        
        // ============================================================
        // EXISTING TEST FUNCTIONS (Easter, Epiphany, Lent, Advent, Tet)
        // ============================================================
        
        function testEaster(year) {
            log(`--- Test Easter nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            const easterDay = litData.easter.getDay();
            assert(easterDay === 0, 
                `[${year}] Easter (${formatDate(litData.easter)}) l√† ${getDayName(litData.easter)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            
            const easterMonth = litData.easter.getMonth();
            const easterDate = litData.easter.getDate();
            const validRange = (easterMonth === 2 && easterDate >= 22) || 
                              (easterMonth === 3 && easterDate <= 25);
            assert(validRange,
                `[${year}] Easter (${formatDate(litData.easter)}) trong kho·∫£ng 22/3 - 25/4`);
            
            const ashDay = litData.ashWednesday.getDay();
            assert(ashDay === 3,
                `[${year}] Ash Wednesday (${formatDate(litData.ashWednesday)}) l√† ${getDayName(litData.ashWednesday)} - ph·∫£i l√† Th·ª© T∆∞`);
            
            const daysDiff = Math.round((litData.easter - litData.ashWednesday) / (24*60*60*1000));
            assert(daysDiff === 46,
                `[${year}] Ash Wednesday c√°ch Easter ${daysDiff} ng√†y - ph·∫£i l√† 46 ng√†y`);
            
            const palmDiff = Math.round((litData.easter - litData.palmSunday) / (24*60*60*1000));
            assert(palmDiff === 7,
                `[${year}] Palm Sunday (${formatDate(litData.palmSunday)}) c√°ch Easter ${palmDiff} ng√†y - ph·∫£i l√† 7 ng√†y`);
            
            const goodFridayDiff = Math.round((litData.easter - litData.goodFriday) / (24*60*60*1000));
            assert(goodFridayDiff === 2,
                `[${year}] Good Friday (${formatDate(litData.goodFriday)}) c√°ch Easter ${goodFridayDiff} ng√†y - ph·∫£i l√† 2 ng√†y`);
            
            const pentecostDiff = Math.round((litData.pentecost - litData.easter) / (24*60*60*1000));
            assert(pentecostDiff === 49,
                `[${year}] Pentecost (${formatDate(litData.pentecost)}) c√°ch Easter ${pentecostDiff} ng√†y - ph·∫£i l√† 49 ng√†y`);
            
            const ascensionDiff = Math.round((litData.ascension - litData.easter) / (24*60*60*1000));
            assert(ascensionDiff === 39,
                `[${year}] Ascension (${formatDate(litData.ascension)}) c√°ch Easter ${ascensionDiff} ng√†y - ph·∫£i l√† 39 ng√†y`);
            
            const ascensionDay = litData.ascension.getDay();
            assert(ascensionDay === 4,
                `[${year}] Ascension (${formatDate(litData.ascension)}) l√† ${getDayName(litData.ascension)} - ph·∫£i l√† Th·ª© NƒÉm`);
        }
        
        function testEpiphanyAndBaptism(year) {
            log(`--- Test Hi·ªÉn Linh & Ph√©p R·ª≠a nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            const epiphanyDay = litData.epiphany.getDay();
            assert(epiphanyDay === 0,
                `[${year}] Epiphany (${formatDate(litData.epiphany)}) l√† ${getDayName(litData.epiphany)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            
            const epiphanyDate = litData.epiphany.getDate();
            const epiphanyMonth = litData.epiphany.getMonth();
            const validEpiphany = epiphanyMonth === 0 && epiphanyDate >= 2 && epiphanyDate <= 8;
            assert(validEpiphany,
                `[${year}] Epiphany (${formatDate(litData.epiphany)}) trong kho·∫£ng 2/1 - 8/1`);
            
            const baptismAfterEpiphany = litData.baptismLord > litData.epiphany;
            assert(baptismAfterEpiphany,
                `[${year}] Baptism (${formatDate(litData.baptismLord)}) sau Epiphany (${formatDate(litData.epiphany)})`);
            
            if (epiphanyDate === 7 || epiphanyDate === 8) {
                const daysDiff = Math.round((litData.baptismLord - litData.epiphany) / (24*60*60*1000));
                assert(daysDiff === 1,
                    `[${year}] Epiphany = ${epiphanyDate}/1 ‚Üí Baptism ng√†y h√¥m sau (${formatDate(litData.baptismLord)}) - diff=${daysDiff}`);
                
                const baptismDay = litData.baptismLord.getDay();
                assert(baptismDay === 1,
                    `[${year}] Baptism (${formatDate(litData.baptismLord)}) l√† ${getDayName(litData.baptismLord)} - ph·∫£i l√† Th·ª© Hai`);
            } else {
                const baptismDay = litData.baptismLord.getDay();
                assert(baptismDay === 0,
                    `[${year}] Baptism (${formatDate(litData.baptismLord)}) l√† ${getDayName(litData.baptismLord)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            }
            
            const dayAfterEpiphany = new Date(litData.epiphany);
            dayAfterEpiphany.setDate(dayAfterEpiphany.getDate() + 1);
            
            if (dayAfterEpiphany < litData.baptismLord) {
                const info = getDayInfo(dayAfterEpiphany, litData);
                const hasSolemnOrFeast = info.saints.some(s => s.rank === 'TRONG' || s.rank === 'KINH');
                
                if (!hasSolemnOrFeast) {
                    assert(info.special && info.special.includes('sau l·ªÖ Hi·ªÉn Linh'),
                        `[${year}] Ng√†y ${formatDate(dayAfterEpiphany)}: "${info.special}" - expected ch·ª©a "sau l·ªÖ Hi·ªÉn Linh"`);
                }
                
                const code = getLiturgicalDayCode(dayAfterEpiphany, litData);
                assert(code.startsWith('600'),
                    `[${year}] M√£ ng√†y ${formatDate(dayAfterEpiphany)}: ${code} - expected b·∫Øt ƒë·∫ßu v·ªõi "600"`);
            }
            
            const baptismCode = getLiturgicalDayCode(litData.baptismLord, litData);
            assert(baptismCode === '5010',
                `[${year}] M√£ Baptism: ${baptismCode} - expected "5010"`);
        }
        
        function testLent(year) {
            log(`--- Test M√πa Chay nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            if (!litData.ashWednesdayTransferred) {
                const ashInfo = getDayInfo(litData.ashWednesday, litData);
                assert(ashInfo.special && ashInfo.special.includes('Tro'),
                    `[${year}] Ash Wednesday (${formatDate(litData.ashWednesday)}): "${ashInfo.special}" - expected ch·ª©a "Tro"`);
                
                const ashCode = getLiturgicalDayCode(litData.ashWednesday, litData);
                assert(ashCode === '3004',
                    `[${year}] M√£ Ash Wednesday: ${ashCode} - expected "3004"`);
            } else {
                log(`[${year}] ‚ö†Ô∏è L·ªÖ Tro b·ªã d·ªùi do tr√πng T·∫øt: ${litData.ashWednesdayTransferNote}`, 'warn');
                stats.warnings++;
            }
            
            const palmInfo = getDayInfo(litData.palmSunday, litData);
            assert(palmInfo.special && palmInfo.special.includes('L√°'),
                `[${year}] Palm Sunday (${formatDate(litData.palmSunday)}): "${palmInfo.special}"`, true);
            
            const goodFridayInfo = getDayInfo(litData.goodFriday, litData);
            assert(goodFridayInfo.color.includes('red'),
                `[${year}] Good Friday (${formatDate(litData.goodFriday)}): color="${goodFridayInfo.color}" - expected "bg-lit-red"`);
            
            assert(goodFridayInfo.special && goodFridayInfo.special.includes('Th·ª© S√°u Tu·∫ßn Th√°nh'),
                `[${year}] Good Friday special: "${goodFridayInfo.special}" - expected ch·ª©a "Th·ª© S√°u Tu·∫ßn Th√°nh"`);
        }
        
        function testAdvent(year) {
            log(`--- Test M√πa V·ªçng nƒÉm ${year} ---`, 'info');
            const litData = getLiturgicalData(year);
            
            const adventDay = litData.adventStart.getDay();
            assert(adventDay === 0,
                `[${year}] Advent Start (${formatDate(litData.adventStart)}) l√† ${getDayName(litData.adventStart)} - ph·∫£i l√† Ch√∫a Nh·∫≠t`);
            
            const adventDate = litData.adventStart.getDate();
            const adventMonth = litData.adventStart.getMonth();
            const validAdvent = (adventMonth === 10 && adventDate >= 27) || 
                               (adventMonth === 11 && adventDate <= 3);
            assert(validAdvent,
                `[${year}] Advent Start (${formatDate(litData.adventStart)}) trong kho·∫£ng 27/11 - 03/12`);
            
            const christKingDiff = Math.round((litData.adventStart - litData.christKing) / (24*60*60*1000));
            assert(christKingDiff === 7,
                `[${year}] Christ King (${formatDate(litData.christKing)}) c√°ch Advent ${christKingDiff} ng√†y - ph·∫£i l√† 7 ng√†y`);
            
            assert(litData.christmas.getMonth() === 11 && litData.christmas.getDate() === 25,
                `[${year}] Christmas: ${formatDate(litData.christmas)} - expected 25/12`);
        }
        
        function testTet(year) {
            log(`--- Test T·∫øt nƒÉm ${year} ---`, 'info');
            
            if (typeof LUNAR_CALENDAR === 'undefined') {
                log(`[${year}] LUNAR_CALENDAR kh√¥ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a`, 'warn');
                stats.warnings++;
                return;
            }
            
            let tetDate = null;
            for (let month = 0; month <= 1; month++) {
                for (let day = 1; day <= 31; day++) {
                    try {
                        const date = new Date(year, month, day);
                        if (date.getMonth() !== month) continue;
                        
                        const lunar = LUNAR_CALENDAR.getLunarDate(date);
                        if (lunar && lunar.day === 1 && lunar.month === 1) {
                            tetDate = date;
                            break;
                        }
                    } catch (e) {}
                }
                if (tetDate) break;
            }
            
            if (tetDate) {
                log(`[${year}] M√πng 1 T·∫øt: ${formatDate(tetDate)} (${getDayName(tetDate)})`, 'info');
                
                if (typeof getTetEvent === 'function') {
                    const tetEvent = getTetEvent(tetDate);
                    assert(tetEvent !== null,
                        `[${year}] getTetEvent(${formatDate(tetDate)}) nh·∫≠n di·ªán M√πng 1 T·∫øt`);
                }
                
                const litData = getLiturgicalData(year);
                const ashTime = litData.ashWednesday.getTime();
                const tetTime = tetDate.getTime();
                const daysDiff = Math.abs(ashTime - tetTime) / (24*60*60*1000);
                
                if (daysDiff <= 3) {
                    log(`[${year}] ‚ö†Ô∏è T·∫øt g·∫ßn L·ªÖ Tro! Kho·∫£ng c√°ch: ${daysDiff} ng√†y`, 'warn');
                    stats.warnings++;
                    
                    if (litData.ashWednesdayTransferred) {
                        assert(true, `[${year}] L·ªÖ Tro ƒë√£ ƒë∆∞·ª£c d·ªùi ƒë√∫ng c√°ch`);
                    }
                }
            } else {
                log(`[${year}] Kh√¥ng t√¨m th·∫•y ng√†y M√πng 1 T·∫øt`, 'warn');
                stats.warnings++;
            }
        }
        
        // ============================================================
        // MAIN TEST RUNNERS
        // ============================================================
        
        async function runStandardTests() {
            clearLog();
            log('üèÅ CH·∫†Y B·ªò TI√äU CHU·∫®N KI·ªÇM TH·ª¨ (A-E)', 'section');
            log('', 'info');
            
            // A. Date & ISO-Key
            testDateAndISOKey();
            updateStats();
            await new Promise(r => setTimeout(r, 50));
            
            // B-E cho nƒÉm hi·ªán t·∫°i v√† m·ªôt s·ªë nƒÉm m·∫´u
            const testYears = [2024, 2025, 2026, 2030, 2050];
            
            for (const year of testYears) {
                document.getElementById('testProgress').textContent = `ƒêang test nƒÉm ${year}...`;
                
                // B. Schema Validation
                testSchemaValidation(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // C. Liturgical Business
                testLiturgicalBusiness(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // D. Month Grid
                testMonthGrid(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
                
                // E. Regression
                testRegressionImportantDates(year);
                updateStats();
                await new Promise(r => setTimeout(r, 20));
            }
            
            log('', 'info');
            log(`‚ú® HO√ÄN TH√ÄNH! Total: ${stats.total}, Passed: ${stats.passed}, Failed: ${stats.failed}, Warnings: ${stats.warnings}`, 'info');
            document.getElementById('testProgress').textContent = 'Ho√†n th√†nh!';
            
            const successRate = ((stats.passed / stats.total) * 100).toFixed(2);
            log(`üìä T·ª∑ l·ªá th√†nh c√¥ng: ${successRate}%`, successRate >= 95 ? 'pass' : 'warn');
        }
        
        async function runTests() {
            clearLog();
            
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);
            const testType = document.getElementById('testType').value;
            
            log(`üöÄ B·∫Øt ƒë·∫ßu test t·ª´ nƒÉm ${startYear} ƒë·∫øn ${endYear}...`, 'info');
            log(`Lo·∫°i test: ${testType}`, 'info');
            log('', 'info');
            
            // Run standard tests first if selected
            if (testType === 'standards' || testType === 'dateISO') {
                testDateAndISOKey();
                updateStats();
            }
            
            const totalYears = endYear - startYear + 1;
            
            for (let year = startYear; year <= endYear; year++) {
                document.getElementById('testProgress').textContent = 
                    `ƒêang test: ${year} (${year - startYear + 1}/${totalYears})`;
                
                try {
                    if (testType === 'all' || testType === 'standards' || testType === 'schema') {
                        testSchemaValidation(year);
                    }
                    if (testType === 'all' || testType === 'standards' || testType === 'business') {
                        testLiturgicalBusiness(year);
                    }
                    if (testType === 'all' || testType === 'standards' || testType === 'monthGrid') {
                        testMonthGrid(year);
                    }
                    if (testType === 'all' || testType === 'standards' || testType === 'regression') {
                        testRegressionImportantDates(year);
                    }
                    if (testType === 'all' || testType === 'easter') {
                        testEaster(year);
                    }
                    if (testType === 'all' || testType === 'epiphany') {
                        testEpiphanyAndBaptism(year);
                    }
                    if (testType === 'all' || testType === 'lent') {
                        testLent(year);
                    }
                    if (testType === 'all' || testType === 'advent') {
                        testAdvent(year);
                    }
                    if (testType === 'all' || testType === 'tet') {
                        testTet(year);
                    }
                } catch (e) {
                    log(`[${year}] ‚ùå ERROR: ${e.message}`, 'fail');
                    stats.failed++;
                    console.error(e);
                }
                
                updateStats();
                
                if (year % 10 === 0) {
                    await new Promise(r => setTimeout(r, 10));
                }
            }
            
            log('', 'info');
            log(`‚ú® Ho√†n th√†nh! Total: ${stats.total}, Passed: ${stats.passed}, Failed: ${stats.failed}, Warnings: ${stats.warnings}`, 'info');
            document.getElementById('testProgress').textContent = 'Ho√†n th√†nh!';
            
            const successRate = ((stats.passed / stats.total) * 100).toFixed(2);
            log(`üìä T·ª∑ l·ªá th√†nh c√¥ng: ${successRate}%`, successRate >= 95 ? 'pass' : 'warn');
        }
        
        // Quick test on load
        window.onload = function() {
            log('üîÑ S·∫µn s√†ng test. Ch·ªçn lo·∫°i test v√† nh·∫•n "Ch·∫°y Test".', 'info');
            log('üí° Nh·∫•n "Ch·∫°y Ti√™u Chu·∫©n" ƒë·ªÉ test b·ªô ti√™u chu·∫©n A-E v·ªõi c√°c nƒÉm m·∫´u.', 'info');
            log('', 'info');
            log('üìã B·ªò TI√äU CHU·∫®N KI·ªÇM TH·ª¨:', 'section');
            log('  A. Date & ISO-key (Timezone Safety)', 'info');
            log('  B. Schema Validation (Data Integrity)', 'info');
            log('  C. Nghi·ªáp v·ª• Ph·ª•ng v·ª• C∆° b·∫£n', 'info');
            log('  D. Month Grid Correctness', 'info');
            log('  E. Regression - Ng√†y Quan Tr·ªçng', 'info');
        };
    </script>
</body>
</html>
